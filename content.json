{"meta":{"title":"TedQin","subtitle":null,"description":"Output is the best input","author":"Ted Qin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"前端工程师面试总结","slug":"前端工程师面试总结","date":"2019-04-17T09:29:13.000Z","updated":"2019-04-17T10:38:19.432Z","comments":true,"path":"2019/04/17/前端工程师面试总结/","link":"","permalink":"http://yoursite.com/2019/04/17/前端工程师面试总结/","excerpt":"","text":"##1 自我介绍我叫秦乐天，本科毕业于同济大学电子与信息工程学院信息安全专业，主要学习计算机科学方面的课程，研究生正就读于伦敦国王学院计算机系统与管理专业，（1学习方面）本科期间参加过程序设计比赛，数学建模和创新实践项目等，获得了上创免答辩立项，全国数学建模大赛二等奖等，本科毕业设计获得了同济大学优秀论文奖。（2工作经历方面）我曾经在饿了么，中科院自动化所和四川长虹股份有限公司的研发岗实习。（3特质）我认为自己的学习能力抗压能力都很强，本科期间自学了python和tensorflow等j机器学习相关工具，以及前端和对应的框架。擅长团队协作，本科期间作为组长带领团队获得了上海大学生创业大赛优秀项目奖。（4工作）我非常喜欢华为“以奋斗者为本”的理念，我一直都想通过自己的努力不断提升和进步，希望自己能够进入华为研发岗并尽自己的一份力 ##2 项目介绍 简单介绍 采用技术/担任职责 主要问题&amp;解决方法 闪光点 ###2.1 上创： 小组组长 主要负责flask项目中的后端算法，参与前后端整合 web应用，协同过滤算法 书籍推荐系统，建立在学校推出的图书评分系统上 应用主要内容分为2块： 1是根据用户推荐书籍 老用户 基于用户推荐：计算用户与其他用户之间的关系度（欧几里得/皮尔逊距离），得到相似度高的用户，并遍历字典，计算不同用户相似度和偏好书籍的权值，得到推荐结果 基于书籍推荐：将评分字典倒置，计算某本书的相似书籍的矩阵，然后相似的计算书籍以及最相似书籍的字典，最后遍历计算不同书籍相似度和评分的权值 新用户： 根据提供的学院，教师/学生，年级等信息进行加权推荐 2是对过往2年的图书借阅记录进行统计 得到过往两年的图书馆真实节约数据，数据预处理：清洗脏数据 数据可视化，用dashboard展现出来 结构：框架：flask前端：输入用户id-submit-通过request.form进入后台-后台算法得出结果-返回后端：python协同过滤算法 遇到的问题： 推荐速度慢 原因：每次执行算法都需要遍历整个借阅记录，每个遍历还需要计算一次距离；计算量大 解决方法：在计算一次后，将字典存储再来，在之后的推荐时直接调用，时间大幅减少 2.2 大创：alexnet分类图像 个人创新项目 python tensroflow 实现优化后的cnn图像分类模型，并调用pytorch预训练的模型，分类1000类不同风格的图像，1w+测试图像超过75准确率。 改进的cnn网络（归一化层，使得图像能有更大尺寸和分辨率的输入 层数更多，分类更准确） 2.3 毕设 也是导师的实验室项目，大二暑假开始做 深度生成对抗网络（dcgan）实现图像修复模型，可以对不同损失面积，不同类型损失区域（中央一半马赛克低像素随机缺失）的图像进行复原， tensorflow+opencv+openface+gpu， 采用技术： 用cnn实现gan模型，包含d和g，g伪造图像d判断真假，博弈训练（d输入真和假，输出0-1；g输出伪造图像并作为输入迭代生成新伪造图像；）修复阶段让trained g迭代一定次数，最后图像和原图像叠加，得到修复后的图像 3个损失函数：训练阶段1个和修复阶段2个（知觉+环境） 梯度下降 4个不同类型的数据集，超过20w张图像 人脸 建筑 综合 3个测试指标提高容错性：峰值信噪比psnr 结构相似性ssim 均方根误差rmse 提高单指标容错性，测试结果比传统的图像修复技术都好 亮点： 优化：直接将原图像和伪造图像叠加不自然；柏松融合 利用插值构建融合部分的像素更加平滑 openface库：预处理阶段，图像中的人脸位置不均，大小不一，openface了一识别人脸并裁减成模型需要的输入 主要问题：训练不平衡：d损失率远大于g，所以给d加了第二个环境损失函数（未受损区域的像素差异），并让两个损失函数加权求和，提高d的训练程度 2.4 中科院自动化所： 人脸检测优化： 在行人检测这种，人脸尺寸小分辨率低的场景下，使用gan进行人脸的超分辨率重建，让人脸检测更加准确 g：生成伪造人脸。d：判断伪造的图像是否真实并且高分辨率 优点：多损失函数加权，相比传统gan更加高效 3损失函数：伪造（接近人脸）；对抗（交叉墒，判断高分辨率）；分辨（分辨人脸） gan人脸生成，并让生成的人脸通过google人脸识别api facenet cnn实现gan adam优化器调整学习旅 gpu加速 2.5 饿了么： arima和lstm模型预测集群作业的数据 arima纯数学模型，对有周期性的序列拟合更好， lstm更适合周期性不强的时间序列问题，并且具有多变量的输入维度（给的原始数据多维，但是一开始并不知道它们之间的相关性），拟合度超过85，准确率超过80 预测未来一周的作业数量 hdfs资源占用情况和作业严重级别， 最后模型部署到公司的日志监控系统上 闪光点：单独写脚本选择出了针对以往数据的最优的arima参数/lstm多维输入 2.6 长虹 对14种不同的票据分类 两个模型 票据量小传统的svm准确率高，量大用cnn（lenet）先做训练，然后分类 难点：预处理和特征提取：黑白文字，且票据的扫描件位置大小层次不齐；cnn能识别图像，但是对于文字识别较难， 优化：opencv库的函数让图像翻转，同样opencv做了数据增强，gan超分辨率，裁减。增加了模型的层数，扩大归一化尺寸； 2.7 数学建模 主要内容是拟合atm交易的数据，采用平均联动聚类以后用核拟合找出特征值，真实数据数据清洗最重要，脏数据的删除，空数据的删除和补充 2.8 智能交通实验室 主要工作是前端构建，并写了一个api连接后端，后端用node采用sklearn（机器学习库），实现了svm，对交通流量数据进行分类 ajax在交通流量实时更新的情况下可以动态更新分类结果 3. 操作系统 3.1 进程和线程的区别是什么？ 进程：分配资源的最小单元 线程：程序执行的最小单元 一个进程可以包含多个线程；进程启动的时候cpu需要给他分配资源，对系统压力比进程大，你可以把线程看成是轻量级的进程。 区别： 进程：有独立数据段，需要分配独立空间（资源大安全高）； 通信机制复杂 线程：共享数据段，不需要分配独立空间（资源小安全低）； 通信机制方便 选取原则： 进程：多机（cpu效率低），稳定安全 线程：频繁的创建和销毁；大量计算；耗时；多核（cpu效率高）；并行操作 3.2 进程间通信的方式有什么？线程间通信的方式有什么？ 进程：socket，管道，信号，消息，共享内存等多种方式 线程：共享变量，管道 3.3 什么是缓存？有哪些缓存的更新算法？ 存储信息避免重复加载； 强缓存：Cache：高速交换存储器；expires 协商缓存：last-modified和if-modified-since：如果缓存过期用 更新算法：Lfu,lru,fifo: lru:least recent update: 最近不访问或者访问少的今后也不会访问（linklist+hashmap实现） 3.4 当你输入域名访问一个网站的时候，背后的过程是什么？ DNS域名解析-TCP三次握手-nginx反向代理进行负载均衡（前后端分离） 3.5 多线程中有哪些锁 偏向锁 加锁和解锁不需要额外的消耗，如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块场景。 轻量级锁：竞争的线程不会阻塞，提高了程序的响应速度。如果始终得不到锁竞争的线程使用自旋会消耗CPU。追求响应时间。同步块执行速度非常快。 重要级锁：线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。追求吞吐量。同步块执行速度较长。 3.6 线程的状态： 初始new 运行runnable-分为就绪ready（调用线程的start()方法，此线程进入就绪状态，sleep（）结束）和运行中running 阻塞blocked-阻塞于锁 等待waiting 超时等待timeed_waiting-可以在指定时间后自行返回 终止 3.7 创建线程两种方式的区别： 1) 继承Thread类，并且覆盖Thread类的run()方法。这种方法的优点是Thread子类对象就是线程对象，具有Thread类的方法，且具有线程体，但是不适应多继承 2) 实现Runnable接口：如果一个类已经继承了一个类还必须要以线程方式运行，就需要实现Runnable接口。实现Runnable接口的类的对象本身并不是线程对象，只是作为一个创建线程对象的目标对象使用。 3.8 聊天都是新建线程，会影响内存，怎么处理 1）开源(增加内存分配) 2）节流(内存优化): 3.9 线程之间共享数据的方式 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。 将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方式也分配给外部类 3.10 进程通信（分别解释），ping工作原理，中断，线程共享父线程的什么， Ping:命令行指令，一般用于检测网络通与不通 ，也叫时延，其值越大，速度越慢 中断是一种特殊的信号，由硬件设备向CPU发送（如敲击键盘）。当CPU接收到中断信号后，就会马上通知操作系统此信号的到来，然后由操作系统负责处理这些新到来的数据。 4 网络协议： 4.1 计算机网络分为哪几层？ 计算机网络如果是OSI模型的话，分为七层： 物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS 数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM, IEEE 802.5/802.2 网络层：IP，IPX，AppleTalk DDP 传输层：TCP，UDP，SPX 会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP 表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML 应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP TCP／IP协议簇模型的话，分为四层： 数据链路层：ARP,RARP 网络层： IP,ICMP,IGMP 传输层：TCP ,UDP,UGP 应用层：Telnet,FTP,HTTP，SMTP,SNMP. 4.2 TCP和UDP有什么区别？什么场景使用TCP，什么场景什么UDP？哪些应用层协议使用了TCP，哪些使用了UDP？ TCP是可靠传输的：用在发送消息的场景（保证用户数据不丢失） UDP是不可靠传输的：传输快：用在聊天室直播等场景（迅速，即使少量丢包不影响） 4.3 窗口滑动协议？ tcp中，两端都维护着窗口： 发送端窗口：由接受端窗口给出的剩余长度来定义 接收端窗口：实现流量控制 4.4 TCP连接需要几次握手？几次挥手？ 3次握手： 两个序号和三个标志位： （1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 1在第一次消息发送中，客户端把自己的初始序号发送给服务端； 2服务端收到，发送一个应答，也包含自身数据的初始序列号 3当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。 * 4次挥手： * 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 * 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 * 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 * 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 4.5 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 4.6 Socket： 客户端和服务端需要采用socket连接时，需要建立socket连接|（应用层与传输层），应用层通过socket向网络发送请求建立tcp/udp连接 4.7 一个简单的server： `4.7 IO NIO AIO：` * Socket在读取消息的时候是阻塞的，NIO是非阻塞，AIO是异步非阻塞， 4.8 你用过什么linux命令？ Ls cd pwd cp rm whereis gedit 4.9 POST和GET的区别： Post是向服务器传送出数据，get是从服务器获取数据 Get通过url传递，post通过request body 4.10 http和tcp： http： tcp是传输层协议，定义的是数据传输和连接方式的规范； http是应用层协议，定义的是传输数据的内容的规范；HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP； TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。 4.11 https: 在http（明文传输）的基础上加入了SSL层进行加密传输 4.12 http2: 所有数据采用二进制编码；一个tcp存在多条流；header压缩； 4.13 ARQ协议： 超时重重传机制：通过确认和超时机制保证数据的正确送达 停止等待arq: 连续arq： 4.14 拥塞处理 慢开始（拥塞处理窗口）-拥塞避免算法-快速重传 4.15 http常见状态码： 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 ##5 数据结构 5.1 表： 顺序表：删除/插入节点需要移位 链表：删除/插入节点即可，无需移位 5.2 栈 队列 栈：插入/删除都在栈头执行 队列：删除在队头，插入在队尾 单链队列： 循环队列： 5.3 查找算法： 顺序搜索： 二分搜索： 指数搜索：index=1-2-4-8-16-32-… 5.4 二叉树 满：full 完全：其它层都满，除了最后一层，如果最后一层不满，节点必须集中在左边 遍历：先序VLR 中序LVR 后序LRV 平衡：对任意节点，左比根小，右比根大： Avl：任一节点的孩子节点高度差最大为1；红黑：非黑即白；Root是黑色；红色的儿子必须是黑色 5.5 堆 最大堆：每个节点值比它的子节点都大，且是完全二叉树 5.6 排序 堆排：while（heap.length） {交换最后一个元素和堆顶元素，删除最后一个元素，然后调整为正确堆} 冒泡：把当前元素和下一个元素比较，当前元素大就交换位置 插排：i++ 以此将当前元素和在它之前的序列中排到正确位置 选择排序：遍历一遍找到最小的数，放到第一位，递归 快排：随机选pivot，左边的数比它大，右边的比它小，对左边的和右边的递归 归并排序：从中拆分成两组，分别排序，递归 最后合并 5.7 字典 哈希表：key-value存储结构； 地址冲突解决： 线性探查（直接往后找空位） 平方探查（往后找空位按照1-2-4-8来找） 链地址（同义词组成单链表） 再哈希（） 5.8 图 表示方法：邻接表，邻接矩阵 最小生成树：原图的连通子图，weight最小 计算方法： prim（从第一个点开始加点，每次找权重最小的边连起来的点） Kruscal（确定所有点，链接权重最小的边） 最短路径：从点u到其他所有点的最短路径 计算方法： dijkstra（给两个集合A={u}，B{其他点}， 从B中找到A的最短路径，加入A） DFS（顶点开始，递归访问相邻点，若有点被访问，则回溯到另一个未被访问的顶点） * BFS（顶点开始，依此访问所有相邻点） 5.9 hashmap与hashtable与hashset的区别 ##6 算法 6.1 进制转换： dec-bin：整数：除2取余；小数：乘2取整 bin-dec： 6.2 左移 &lt;&lt;：10 在二进制中表示为 1010 ，左移一位后变成 10100 6.3 算数右移：10 在二进制中表示为 1010 ，右移一位后变成 101 6.4 动态规划： 将问题拆分成子问题，得到子解就得到了大解（斐波那契数列) ##7 git： checkout：定位到某分支 branch：创建新分支 merge：合并 恢复先前的提交：让head后移一位， commit：当当前的改动提交到本地的版本库 reset和rebase：reset不修改commit；rebase会修改commit pull和fetch：pull会更新本地代码库；fetch是取回远端更新，不会对本地执行merge 8 前端： 8.1 js基本类型： null undefined Boolean number string symbol(es6新加入) object 8.2 类型转换 String(234)=’234’ 对象转基本类型：tostring，（先valueof） 字符串转number: var newNumber = parseInt(str, radix) #radix为基数 0对应基数10 8.3 ==和===： ===：严格相等，会比较类型和值 ==：先类型转化再比较值 8.4 new： 新生成一个对象-链接到原型-绑定this-返回新对象 8.5 this： 只在函数内部使用，自动生成的一个对象，绑定函数 8.6 执行上下文： 当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链: 包含自身变量对象和上级变量对象的列表 this 8.7 闭包： 函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包 8.8 深浅拷贝 直接赋值进行拷贝：两者的值会是同一个引用 浅拷贝：b={…a} 深拷贝：通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 8.9 commonjs： node规范：引入了模块机制：require export 8.10 另一种amd：异步定义 8.11 防抖： 防止二次点击操作：防止函数多次调用（例如用户多次滑动页面）：通过限制需要经过的时间，直到再次调用函数，将多次执行-&gt;最后一次执行 8.12 节流：也可防抖，在固定时间内只能调用一次，多次执行-&gt;每隔一段时间执行 8.13 继承 es5提出，在父对象的原型链上定义属性 class 8.14 call apply bind的区别： call，apply：改变this的指向，让新的对象可以执行该函数； bind最后会返回一个函数 8.15 promise： 初始态pending：通过resolve和reject改变 8.16 generator 异步编程 函数名前加*，可以返回next进行代码暂停 8.17 map flatmap reduce map：Map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后append到新的数组中 flatmap：降纬 reduce：作用是数组中的值组合起来，最终得到一个值 8.18 async await async函数返回promise 异步调用 8.19 proxy： 自定义对象中的操作，实现一个数据绑定和监听 8.20 为什么 0.1 + 0.2 != 0.3 js采用ieee 64位版本，0．1和0.2都是无限循环的二进制，末尾会进位，不是标准的3.00000 8.21 var let const的区别： 作用域不同 8.22 正则表达式 ##9 浏览器 9.1 事件机制: 事件触发3阶段： 事件代理：子节点动态生成，应注册在父节点上（节省空间） 9.2 cookie session的区别： cookie存储sessionid 9.3 浏览器兼容性： css兼容：定制自己的reset.css 交互兼容性： 9.4 js组成： ecmascript（定义脚本语言的属性、方法和对象）+dom（把整个页面规划成由节点层级构成的文档）+bom（处理浏览器宽口和框架） 9.5 ajax优缺点： 优：减轻服务器的负担，按需取数据，最大程度减少冗余请求，局部刷新。 缺：浏览器之间有差异，对流媒体和移动设备支持不够好 9.6 浏览器内核 渲染引擎：负责取得网页的内容、整理讯息，以及计算网页的显示方式 js引擎：析和执行js来实现网页的动态效 9.7 事件委托 9.8 window的onload事件和domcontentloaded谁先谁后？ 9.9 跨域问题： 协议，域名或端口有一个不同就是跨域，ajax请求会失败 解决：jsonp：利用script标签（没有跨域限制的漏洞）指向地址并提供回调函数来接收（只限于get） cors：该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 document.domain：该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 postmessage：这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域 9.10 restful：api风格，用URL定位资源，用HTTP描述操作 9.11 事件循环：浏览器：同步执行代码-遇到settimeout，把该事件放到事件队列（遇到微任务放到微任务空间）继续执行直到同步代码执行结束；之后执行微任务空间，然后执行事件队列中的事件，反复循环node：执行顺序不一定 9.12 存储：* cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 ##10 性能 10.1 预加载： 有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 10.2 预渲染： 10.3 优化渲染过程： 懒执行（某些逻辑延迟到使用时再计算） 懒加载（不关键的资源延后加载） 10.4 图片优化：减小像素点+减小每个像素点的颜色+加载优化 文件优化：css文件放在head中，script标签放在body底部（js会阻塞渲染） 11 安全 11.1 xss： 跨网站指令码：这类攻击包含html以及恶意脚本语言，修改html节点或执行js 防御：白名单（csp内容安全层）/黑名单过滤/转义输出 11.2 csrf： 跨站请求伪造：挟持用户在当前登陆设备上攻击网站 在评论（get接口）中加入恶意代码 防御：禁止修改get 12 框架 12.1 mvvm： model+view+viewmodel model：后台数据模型，业务逻辑 view：界面，ui组件 viewmodel：监听模型数据的改变和控制试图 model=&gt;view：将后端数据转换为页面，实现方式：数据绑定 view=&gt;model：将页面转换为后台数据，实现方式：dom事件监听 12.2 路由：监听URL变化，然后匹配路由规则： 路由方式：hash模式：路由#后面加hash值 history模式：pushstate（）replacestate（）对浏览器记录进行修改 12.3 virtual dom： 用js模拟dom对象（节点和渲染） 13 vue 13.1 nexttick： 下次dom更新循环结束之后执行延迟回调，用于获得更新后的dom 13.2 生命周期分析 vue实例从创建到销毁的过程：创建前/后-挂载dom前/后-渲染更新前/后-卸载前/后组件在初始化或者数据更新时会出发的钩子函数（类似回调） 第一次加载页面会触发：beforecrate created beforemount mounted 13.3 vue组件参数传递： 父-&gt;子：子通过props方法接受数据 子-&gt;父：emit方法传递参数 14 死锁 系统资源不足/分配不当，进程推进顺序不合理，争夺有限的资源而陷入死锁 synchronized锁和lock的区别： 同步锁：可以放在方法或者代码块前面 需要指定上锁的对象 lock：可以代替同步锁，但是有中断，和定时锁等待 区别： 资源竞争激烈：lock性能比同步好； 反之：同步好 同步锁可以在代码块前面实现 死锁的条件 互斥：一个进程使用一个资源 请求与保持：一个进程请求资源造成阻塞，且对已有的资源不放 不剥夺：进程已获得资源在使用完之前，不能强行剥夺 循环等待：若干进程形成循环等待资源的关系 摈弃死锁的条件： 合理分配资源 避免进程永久占据资源 防止处于等待状态下的进程占用资源 15 设计模式： 15.1 单例模式： 确保一个类只有一个实例，确保了封装行：将构造函数声明为private 15.2 工厂模式： 创建类时不会暴露创建内容，而是通过接口实例化类；更方便构造对象 15.3 装饰器设计模式： 动态给对象添加属性或函数； 15.4 观察者模式： 对象1对多，多个观察者可以监听某个对象；自动更新","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"c++tips笔记","slug":"cpp笔记","date":"2018-10-18T15:19:02.000Z","updated":"2018-10-30T16:20:16.952Z","comments":true,"path":"2018/10/18/cpp笔记/","link":"","permalink":"http://yoursite.com/2018/10/18/cpp笔记/","excerpt":"","text":"指针* 是取值运算符，对地址使用可以获得地址中储存的数值。对于指针a，*a表示取a中的值 在 定义 时， 是一个标识符，声明该变量是一个指针，比如说int p; 那p就是一个指向int型的指针 在 调用 时， p是指针p指向的那个变量，比如说之前有int a=5；int p=&amp;a；那么p的值是a的地址，也就是指针p指向a， p则等于a的值，即p=5。 &amp; &amp;在 定义 时则是引用，比如说有定义int a=5；再定义int b=&amp;a；那么这里的b则引用a的值，即b=5，而再给b赋值：b=10，a的值也会变为10。 &amp;在 调用 是地址运算符，对变量使用可以获得该变量的地址, 对于变量b，&amp;b表示取b的地址 example 先定义有int x = 0；int *p = &amp;x； 若定义函数： void fun1（int a）{ a=5；} ，则调用：fun1(x); 之后，x还等于0；因为fun1函数只改变了形参a的值，a只是fun1函数里的局部变量，调用fun1(x)相当于是“a=x;a=5;”，x没变； 若定义函数：void fun2（int &amp;a）{ a=5；} ， 则调用：fun2(x); 之后，x等于5；因为这里的a引用了x的值； 若定义函数：void fun3（int a）{ a=5；} ， 则调用：fun3(p); 之后，x也等于5；因为fun3函数的参数a是一个指针，相当于a=p； a则与 p指向同一地址，改变 a即改变p即x return *this: strcpy和strncpy：strcpy(char *ch1, char *ch2)： 直接将ch2指向的由”\\0”结束的字符串复制到ch1，ch1必须有足够的空间来存储ch2 若ch2长于ch1，还是会复制，但是ch1会溢出* strncpy(char *ch1, char *ch2, n): 将ch2中最多n个字符复制到ch1 如果n&gt;ch1长度，ch1溢出 如果n&lt;ch1长度，且如果 ch2长度&lt;=ch1长度，则ch2前n个字符复制到ch1 ch2长度&gt;ch1长度，出错 建议：将n设置为ch1长度","categories":[],"tags":[]},{"title":"mac常用指令","slug":"mac常用指令","date":"2018-10-10T01:55:04.000Z","updated":"2018-10-16T11:50:18.650Z","comments":true,"path":"2018/10/10/mac常用指令/","link":"","permalink":"http://yoursite.com/2018/10/10/mac常用指令/","excerpt":"","text":"ps: * 指令名称 指令 实例 参考：https://www.jianshu.com/p/8803bf591956 基本指令目录操作 创建目录 mkdir mkdir dirname 删除目录 rmdir rmdir dirname 移动或重命名一个目录 mvdir mvdir dir1 dir2 改变当前目录 rmdir rmdir dirname 显示当前目录的路径名 pwd pwd 显示当前目录的内容 ls ls -la 文件操作 显示文件内容或连接文件 cat cat filename 显示非文本文件的内容 od od -c filename 复制文件或目录 cp cp file1 file2 删除文件或目录 rm rm filename 改变文件名或所在目录 mv mv file1 file2 使用匹配表达式查找文件 find find . -name &quot;*.c&quot; -print 显示文件类型 file file filename 选择操作 显示文件的最初几行 head head -20 filename 显示文件的最后几行 tail tail -15 filename 显示文件每行中的某些域 cut cut -f1,7 -d: /etc/passwd 从标准输入中删除若干列 colrm colrm 8 20 file2 排序或归并文件 sort sort -d -f -u file1 去掉文件中的重复行 uniq uniq file1 file2 显示两有序文件的公共和非公共行 comm comm file1 file2 统计文件的字符数、词数和行数 wc wc filename 给文件加上行号 nl nl file1 &gt;file2 进程操作 显示进程当前状态 ps ps u 终止进程 kill kill -9 30142 时间操作 显示系统的当前日期和时间 diff diff file1 file2 显示⽇日历 cal cal 8 1996 统计程序的执⾏行行时间 time time a.out 网络与通信操作 远程登录 telnet telnet hpc.sp.net.edu.cn 远程登录 rlogin rlogin hostname -l username 在远程主机执⾏行行指定命令 rsh rsh f01n03 date 在本地主机与远程主机之间传输⽂文件 ftp ftp[ftp.sp.net.edu.cn] 在本地主机与远程主机之间复制⽂文件 rcp rcp[ftp.sp.net.edu.cn] 给⼀一个⽹网络主机发送 回应请求 ping ping hpc.sp.net.edu.cn 阅读和发送电⼦子邮件 mail mail 允许或拒绝接收报⽂文 mesg mesg n core shell 指令 列列出最近执⾏行行过的⼏条命令及编号 history history 重复执⾏行行最近执⾏过的某条命令 r r-2 给某个命令定义别名 alias alias del=rm -i 取消对某个别名的定义 diff diff file1 file2 比较并显示两个文件的差异 unalias unalias del 其它命令 显示操作系统的有关信息 uname uname -a 清除屏幕或窗⼝口内容 clear clear 显示当前所有设置过的环境变量量 env env 列列出当前登录的所有⽤用户 who who 显示当前正进⾏行行操作的⽤用户名 whoami whoami 显示终端或伪终端的名称 tty tty 显示或重置控制键定义 stty stty -a 查询磁盘使⽤用情况 du du -k subdirdf 显示⽂文件系统的总空间和可⽤用空间 /tmp 显示当前系统活动的总信息 w 在本地主机与远程主机之间复制⽂文件 rcp rcp[ftp.sp.net.edu.cn] 给⼀一个⽹网络主机发送 回应请求 ping sudo命令 临时使⽤用root权限来编辑/etc/shadow密码⽂文件 sudo gedit /etc/shadow 注意$和#的变化，#表示你在最⾼高权限root⾥里里⾯面","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"hexo搭建blog常用命令","slug":"hexo搭建blog常用命令","date":"2018-10-10T01:29:32.000Z","updated":"2019-04-17T09:08:16.332Z","comments":true,"path":"2018/10/10/hexo搭建blog常用命令/","link":"","permalink":"http://yoursite.com/2018/10/10/hexo搭建blog常用命令/","excerpt":"","text":"常规搭建常规指令hexo new &quot;blogname&quot; #新建博客 hexo g #生成 hexo s #启动服务器预览 hexo d #部署 hexo clean #清除缓存 更换设备搭建参考：https://www.zhihu.com/question/21193762/answer/103097754 打开git bash，在用户主目录下运行： ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把其中的邮件地址换成自己的邮件地址，然后一路回车 最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。 下载Node.js，并安装. 打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo 下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。 1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文 件，像站点配置_config.yml，theme文件夹里面的主题， 以及source里面自己写的博客文件，这些肯定要拷贝的。除 此之外，还有 三个文件需要有，就是scaffolds文件夹（文章的模板）、 package.json（说明使用哪些包）和.gitignore（限定在 提交的时候哪些文件可以忽略）。其实，这三个文件不是我们 修改的，所以即使丢失了，也没有关系，我们可以建立一个新 的文件夹，然后在里面执行hexo init，就会生成这三个文 件，我们只需要将它们拷贝过来使用即可。总结： _config.yml，theme/，source/，scaffolds/， package.json，.gitignore，是需要拷贝的。 &nbsp; （2）再讨论下哪些文件是不必拷贝的，或者说可以删除的： 首先是.git文件，无论是在站点根目录下，还是主题目录下 的.git文件，都可以删掉。然后是文件夹 node_modules（在用npm install会重新生成）， public（这个在用hexo g时会重新生成），.deploy_git 文件夹（在使用hexo d时也会重新生成），db.json文件。 其实上面这些文件也就是.gitignore文件里面记载的可以忽 略的内容。总结：.git/，node_modules/， public/，.deploy_git/，db.json文件需要删除。 在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了： （1）为了使用hexo d来部署到git上，需要安装 npm install hexo-deployer-git --save （2）为了建立RSS订阅，需要安装 npm install hexo-generator-feed --save （3）为了建立站点地图，需要安装 npm install hexo-generator-sitemap --save 插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！","categories":[],"tags":[]},{"title":"目前的learning plan","slug":"基础知识","date":"2018-07-15T20:23:22.000Z","updated":"2019-04-17T09:13:37.516Z","comments":true,"path":"2018/07/15/基础知识/","link":"","permalink":"http://yoursite.com/2018/07/15/基础知识/","excerpt":"","text":"####必须掌握的基础知识，主要分为数据结构、算法、操作系统、数据库、前端等。不定期更新 数据结构 表 堆栈 队列 数组 树 完全二叉树：除了最后一层以外，其余层必满；最后一层可以是满，如果不满，则节点必须集中在左边 最大堆：1.必须是完全二叉树 2.节点的值必须大于左右子树的值 二叉搜索树：左孩子比父母小，右孩子比父母大。 avl树：一种平衡二叉搜索树，并且任意节点的孩子节点高度差最大为1. 平衡因子：某节点的平衡因子是该节点左子树的高度减右子树的高度（avl只能是0，1，-1 红黑树： 节点是红色或黑色。 根是黑色。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 图 算法 排序 查找 hash 算法思想-递归 算法思想-贪心 算法思想-回溯 算法思想-分支 算法思想-动态规划 数据库 索引 视图 触发器 范式 锁 存储过程 事物 B+树 E-R图 3.10补充-mysql、mongodb 操作系统 并发性（concurrence） 在一个系统（或者一段时间）中，有多个同时执行的程序进行计算，并且它们之间存在潜在的交互。优点：资源利用率高、程序设计更简化、程序响应更快、系统性能更高；缺点：存在并发性的系统会有不同的程序运行路径，所以系统的处理结果会有不确定性。 进程（process）、线程（thread） 一个应用程序包含一个或多个相互协作的进程。 进程：一块包含一些资源的内存区域，组成为一段一定大小（4GB）的线性内存空间。 线程：进程中包含的一个或多个执行单元，无内存空间，只有指针、栈、寄存器、数据区。 一个程序至少有一个进程，一个进程至少有一个线程。进程和线程都是系统（程序）的执行单元。 差别：进程具有独立的地址空间（供它包含的线程访问），线程没有，所以如果一个进程崩溃，在保护模式下不会对其他进程产生影响；而一个线程死掉就等于整个进程死掉（多进程程序比多线程程序健壮），但是进程切换时耗费的资源多，效率差。 异步、同步处理、阻塞和非阻塞 同步调用：调用之后就能得到结果 异步调用：调用之后需要其他方法（状态、通知、回调函数）来得到结果。 同步线程：两个线程的步调要一致，如果二者运行速度不一样，则快的等慢的（快的阻塞一下等慢的）。 异步线程：两个线程的步调不一致，各自独立运行。 同步I/O：不发送成功或失败状态，一直等待。 异步I/O：输入/输出时立即返回成功或失败的状态。 阻塞：进程或线程停止。 阻塞I/O：资源不可用时（输入/输出未完成，I/O一直阻塞，直到完成。 非阻塞I/O：资源不可用超过一定时间后，直接结束本次I/O。 调度、死锁 死锁：两个或多个执行单元之间相互等待对方结束而引起阻塞的情况。 例：T1有R1的访问权、T2有R2的访问权。 T1想访问R2，同时T2想访问R1，此时T1和T2都要等待对方给出权限，形成死锁。 存储器管理 文件管理 IO阻塞 用户态、核心态 nodejs express框架、es6、es7 前端框架 react、vuejs、angularjs IOS开发","categories":[],"tags":[{"name":"plan","slug":"plan","permalink":"http://yoursite.com/tags/plan/"}]},{"title":"《深入浅出NodeJS》读书笔记","slug":"《深入浅出NodeJS》读书笔记","date":"2018-07-15T19:20:07.000Z","updated":"2019-02-10T15:46:19.885Z","comments":true,"path":"2018/07/15/《深入浅出NodeJS》读书笔记/","link":"","permalink":"http://yoursite.com/2018/07/15/《深入浅出NodeJS》读书笔记/","excerpt":"","text":"##第一章 Node Node：“一个强制不共享任何资源的单线程、单进程系统，通过协议构建不同的node来形成一个大型的网路应用，每一个node为一个节点”，这是书中给的解释原文 非阻塞I/O 书中多次提到的概念，我理解的非阻塞就是线程或进程的停止， 特点 1.异步 2.事件（随意绑定事件），时间绑定轻量级、松耦合 3.回调函数 Ajax请求：快速动态刷新网页，不刷新，直接更新参数 读完第一章以后，觉得云里雾里，这本书对于没有JS基础的人来说有点头疼。不过能肯定的是nodejs是一门异步I/O的语言，和python等编程习惯不一样，需要适应。 至此，我决定先啃《js高级程序设计第三版》这本书，对js有一定的了解以后再来学习nodejs。 ##第二章 C/S模式：客户/服务器模式，例如微信等B/S模式：浏览器/服务器模式，例如各种web应用 CommonJS规范： 相比于python的import，JAVA的类文件等，js是没有模块引入机制的，只能通过&lt;script&gt;标签这种杂乱的方式引入代码。在nodejs未出现之前，js只能用于前端，只有Rhino等后端javascript运行环境来作为小工具。node这么多年发展以来，已经形成了一套响应的规范，也就是CommonJS规范。 1.模块引用：var math = require(&#39;math&#39;); 2.模块定义：export.add = function(){...;return sum}; export.increment = function(val){}; 3.模块标识： node模块实现： node引入模块需要3个步骤：路径分析、文件定位、编译执行，其中系统自带的模块为核心模块，直接随node启动时加载进内存，加载速度快；用户自定义的模块称为文件模块，在运行时动态加载，慢。 1.路径分析：require(&#39;标识符&#39;)；//分析标识符，标识符主要分为： *核心模块，如http、fs、path等。 *.或..等相对路径文件模块 *以/开始的绝对路径文件模块 *非路径形式的文件模块，如自定义的connect模块 （自定义模块非核心模块和路径形式的模块，分析速度最慢） 2.文件定位： *扩展名分析：模块文件可以不带扩展名，自动按.js、.json、.node顺序补全。 *目标分析和包： 3.模块编译 *核心模块一般为C/C++或javascript编译，所有的都转换为C/C++然后编译 4.内建模块：全由C/C++编译的模块，使用： process.binding(&#39;标识符&#39;) 来进行导出 包与NPM： &quot;package.json&quot;：包含包的所有信息（版本、名称、作者等） NPM已经是一个包共享平台，实现第三方模块的发布、安装和依赖。 前后端共用模块： 前端规范：AMD规范、CMD规范 1.AMD规范定义的模块需要用define： define(function(){...}) 2.CMD规范申明时要指定所有的依赖 ##第三章 tips：js异步回调函数复习Promise() resolve()： pending-&gt;fulfilled pending-&gt;rejected reject()","categories":[],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]}]}