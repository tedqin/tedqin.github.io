{"meta":{"title":"一条想成为大佬的咸鱼","subtitle":null,"description":null,"author":"Ted Qin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"c++tips笔记","slug":"c-tips笔记","date":"2018-10-18T15:19:02.000Z","updated":"2018-10-19T10:19:49.177Z","comments":true,"path":"2018/10/18/c-tips笔记/","link":"","permalink":"http://yoursite.com/2018/10/18/c-tips笔记/","excerpt":"","text":"指针* 是取值运算符，对地址使用可以获得地址中储存的数值。对于指针a，*a表示取a中的值 在 定义 时， 是一个标识符，声明该变量是一个指针，比如说int p; 那p就是一个指向int型的指针 在 调用 时， p是指针p指向的那个变量，比如说之前有int a=5；int p=&amp;a；那么p的值是a的地址，也就是指针p指向a， p则等于a的值，即p=5。 &amp; &amp;是地址运算符，对变量使用可以获得该变量的地址, 对于变量b，&amp;b表示取b的地址 &amp;，则是引用，比如说有定义int a=5；再定义int b=&amp;a；那么这里的b则引用a的值，即b=5，而再给b赋值：b=10，a的值也会变为10。 example 先定义有int x = 0；int *p = &amp;x； 若定义函数： void fun1（int a）{ a=5；} ，则调用：fun1(x); 之后，x还等于0；因为fun1函数只改变了形参a的值，a只是fun1函数里的局部变量，调用fun1(x)相当于是“a=x;a=5;”，x没变； 若定义函数：void fun2（int &amp;a）{ a=5；} ， 则调用：fun2(x); 之后，x等于5；因为这里的a引用了x的值； 若定义函数：void fun3（int a）{ a=5；} ， 则调用：fun3(p); 之后，x也等于5；因为fun3函数的参数a是一个指针，相当于a=p； a则与 p指向同一地址，改变 a即改变p即x return *this: strcpy和strncpy：strcpy(char *ch1, char *ch2)： 直接将ch2指向的由”\\0”结束的字符串复制到ch1，ch1必须有足够的空间来存储ch2 若ch2长于ch1，还是会复制，但是ch1会溢出* strncpy(char *ch1, char *ch2, n): 将ch2中最多n个字符复制到ch1 如果n&gt;ch1长度，ch1溢出 如果n&lt;ch1长度，且如果 ch2长度&lt;=ch1长度，则ch2前n个字符复制到ch1 ch2长度&gt;ch1长度，出错 建议：将n设置为ch1长度","categories":[],"tags":[]},{"title":"xcode调试技巧-常用命令和断点","slug":"xcode调试技巧-常用命令和断点","date":"2018-10-11T23:07:51.000Z","updated":"2018-10-11T23:50:14.674Z","comments":true,"path":"2018/10/12/xcode调试技巧-常用命令和断点/","link":"","permalink":"http://yoursite.com/2018/10/12/xcode调试技巧-常用命令和断点/","excerpt":"","text":"新坑","categories":[],"tags":[]},{"title":"mac常用指令","slug":"mac常用指令","date":"2018-10-10T01:55:04.000Z","updated":"2018-10-16T11:50:18.650Z","comments":true,"path":"2018/10/10/mac常用指令/","link":"","permalink":"http://yoursite.com/2018/10/10/mac常用指令/","excerpt":"","text":"ps: * 指令名称 指令 实例 参考：https://www.jianshu.com/p/8803bf591956 基本指令目录操作 创建目录 mkdir mkdir dirname 删除目录 rmdir rmdir dirname 移动或重命名一个目录 mvdir mvdir dir1 dir2 改变当前目录 rmdir rmdir dirname 显示当前目录的路径名 pwd pwd 显示当前目录的内容 ls ls -la 文件操作 显示文件内容或连接文件 cat cat filename 显示非文本文件的内容 od od -c filename 复制文件或目录 cp cp file1 file2 删除文件或目录 rm rm filename 改变文件名或所在目录 mv mv file1 file2 使用匹配表达式查找文件 find find . -name &quot;*.c&quot; -print 显示文件类型 file file filename 选择操作 显示文件的最初几行 head head -20 filename 显示文件的最后几行 tail tail -15 filename 显示文件每行中的某些域 cut cut -f1,7 -d: /etc/passwd 从标准输入中删除若干列 colrm colrm 8 20 file2 排序或归并文件 sort sort -d -f -u file1 去掉文件中的重复行 uniq uniq file1 file2 显示两有序文件的公共和非公共行 comm comm file1 file2 统计文件的字符数、词数和行数 wc wc filename 给文件加上行号 nl nl file1 &gt;file2 进程操作 显示进程当前状态 ps ps u 终止进程 kill kill -9 30142 时间操作 显示系统的当前日期和时间 diff diff file1 file2 显示⽇日历 cal cal 8 1996 统计程序的执⾏行行时间 time time a.out 网络与通信操作 远程登录 telnet telnet hpc.sp.net.edu.cn 远程登录 rlogin rlogin hostname -l username 在远程主机执⾏行行指定命令 rsh rsh f01n03 date 在本地主机与远程主机之间传输⽂文件 ftp ftp[ftp.sp.net.edu.cn] 在本地主机与远程主机之间复制⽂文件 rcp rcp[ftp.sp.net.edu.cn] 给⼀一个⽹网络主机发送 回应请求 ping ping hpc.sp.net.edu.cn 阅读和发送电⼦子邮件 mail mail 允许或拒绝接收报⽂文 mesg mesg n core shell 指令 列列出最近执⾏行行过的⼏条命令及编号 history history 重复执⾏行行最近执⾏过的某条命令 r r-2 给某个命令定义别名 alias alias del=rm -i 取消对某个别名的定义 diff diff file1 file2 比较并显示两个文件的差异 unalias unalias del 其它命令 显示操作系统的有关信息 uname uname -a 清除屏幕或窗⼝口内容 clear clear 显示当前所有设置过的环境变量量 env env 列列出当前登录的所有⽤用户 who who 显示当前正进⾏行行操作的⽤用户名 whoami whoami 显示终端或伪终端的名称 tty tty 显示或重置控制键定义 stty stty -a 查询磁盘使⽤用情况 du du -k subdirdf 显示⽂文件系统的总空间和可⽤用空间 /tmp 显示当前系统活动的总信息 w 在本地主机与远程主机之间复制⽂文件 rcp rcp[ftp.sp.net.edu.cn] 给⼀一个⽹网络主机发送 回应请求 ping sudo命令 临时使⽤用root权限来编辑/etc/shadow密码⽂文件 sudo gedit /etc/shadow 注意$和#的变化，#表示你在最⾼高权限root⾥里里⾯面","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"hexo搭建blog常用命令","slug":"hexo搭建blog常用命令","date":"2018-10-10T01:29:32.000Z","updated":"2018-10-23T11:35:59.544Z","comments":true,"path":"2018/10/10/hexo搭建blog常用命令/","link":"","permalink":"http://yoursite.com/2018/10/10/hexo搭建blog常用命令/","excerpt":"","text":"常规搭建常规指令更换设备搭建参考：https://www.zhihu.com/question/21193762/answer/103097754 打开git bash，在用户主目录下运行： ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把其中的邮件地址换成自己的邮件地址，然后一路回车 最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。 下载Node.js，并安装. 打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo 下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。 1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文 件，像站点配置_config.yml，theme文件夹里面的主题， 以及source里面自己写的博客文件，这些肯定要拷贝的。除 此之外，还有 三个文件需要有，就是scaffolds文件夹（文章的模板）、 package.json（说明使用哪些包）和.gitignore（限定在 提交的时候哪些文件可以忽略）。其实，这三个文件不是我们 修改的，所以即使丢失了，也没有关系，我们可以建立一个新 的文件夹，然后在里面执行hexo init，就会生成这三个文 件，我们只需要将它们拷贝过来使用即可。总结： _config.yml，theme/，source/，scaffolds/， package.json，.gitignore，是需要拷贝的。 &nbsp; （2）再讨论下哪些文件是不必拷贝的，或者说可以删除的： 首先是.git文件，无论是在站点根目录下，还是主题目录下 的.git文件，都可以删掉。然后是文件夹 node_modules（在用npm install会重新生成）， public（这个在用hexo g时会重新生成），.deploy_git 文件夹（在使用hexo d时也会重新生成），db.json文件。 其实上面这些文件也就是.gitignore文件里面记载的可以忽 略的内容。总结：.git/，node_modules/， public/，.deploy_git/，db.json文件需要删除。 在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了： （1）为了使用hexo d来部署到git上，需要安装 npm install hexo-deployer-git --save （2）为了建立RSS订阅，需要安装 npm install hexo-generator-feed --save （3）为了建立站点地图，需要安装 npm install hexo-generator-sitemap --save 插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！","categories":[],"tags":[]},{"title":"迷茫","slug":"迷茫","date":"2018-08-11T17:08:22.000Z","updated":"2018-08-11T10:29:30.000Z","comments":true,"path":"2018/08/11/迷茫/","link":"","permalink":"http://yoursite.com/2018/08/11/迷茫/","excerpt":"","text":"对未来的方向不是很明确，目前暂时的新知识学习计划是JS-NODEJS-IOS 觉得自己并不擅长后端开发，但是感觉web开发的前景不是很好，移动开发可能是对我最好的一个选择。 于是决定自己先分别上手一下，nodejs、js和ios简单应用，看看自己更喜欢哪个。 继续nodejs吧，坚持","categories":[],"tags":[]},{"title":"新坑-IOS开发","slug":"新坑-IOS开发","date":"2018-08-11T16:51:18.000Z","updated":"2018-08-11T09:51:20.000Z","comments":true,"path":"2018/08/11/新坑-IOS开发/","link":"","permalink":"http://yoursite.com/2018/08/11/新坑-IOS开发/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"目前的learning plan","slug":"目前的learning-plan","date":"2018-07-15T20:23:22.000Z","updated":"2018-08-11T10:08:08.000Z","comments":true,"path":"2018/07/15/目前的learning-plan/","link":"","permalink":"http://yoursite.com/2018/07/15/目前的learning-plan/","excerpt":"","text":"数据结构 表 堆栈 队列 数组 树 图 算法 排序 查找 hash 算法思想-递归 算法思想-贪心 算法思想-回溯 算法思想-分支 算法思想-动态规划 数据库 索引 视图 触发器 范式 锁 存储过程 事物 B+树 E-R图 3.10补充-mysql、mongodb 操作系统 并发性（concurrence） 在一个系统（或者一段时间）中，有多个同时执行的程序进行计算，并且它们之间存在潜在的交互。优点：资源利用率高、程序设计更简化、程序响应更快、系统性能更高；缺点：存在并发性的系统会有不同的程序运行路径，所以系统的处理结果会有不确定性。 进程（process）、线程（thread） 一个应用程序包含一个或多个相互协作的进程。 进程：一块包含一些资源的内存区域，组成为一段一定大小（4GB）的线性内存空间。 线程：进程中包含的一个或多个执行单元，无内存空间，只有指针、栈、寄存器、数据区。 一个程序至少有一个进程，一个进程至少有一个线程。进程和线程都是系统（程序）的执行单元。 差别：进程具有独立的地址空间（供它包含的线程访问），线程没有，所以如果一个进程崩溃，在保护模式下不会对其他进程产生影响；而一个线程死掉就等于整个进程死掉（多进程程序比多线程程序健壮），但是进程切换时耗费的资源多，效率差。 异步、同步处理、阻塞和非阻塞 同步调用：调用之后就能得到结果 异步调用：调用之后需要其他方法（状态、通知、回调函数）来得到结果。 同步线程：两个线程的步调要一致，如果二者运行速度不一样，则快的等慢的（快的阻塞一下等慢的）。 异步线程：两个线程的步调不一致，各自独立运行。 同步I/O：不发送成功或失败状态，一直等待。 异步I/O：输入/输出时立即返回成功或失败的状态。 阻塞：进程或线程停止。 阻塞I/O：资源不可用时（输入/输出未完成，I/O一直阻塞，直到完成。 非阻塞I/O：资源不可用超过一定时间后，直接结束本次I/O。 调度、死锁 死锁：两个或多个执行单元之间相互等待对方结束而引起阻塞的情况。 例：T1有R1的访问权、T2有R2的访问权。 T1想访问R2，同时T2想访问R1，此时T1和T2都要等待对方给出权限，形成死锁。 存储器管理 文件管理 IO阻塞 用户态、核心态 nodejs express框架、es6、es7 前端框架 react、vuejs、angularjs IOS开发","categories":[],"tags":[{"name":"plan","slug":"plan","permalink":"http://yoursite.com/tags/plan/"}]},{"title":"《深入浅出NodeJS》读书笔记","slug":"《深入浅出NodeJS》读书笔记","date":"2018-07-15T19:20:07.000Z","updated":"2018-08-12T15:09:50.000Z","comments":true,"path":"2018/07/15/《深入浅出NodeJS》读书笔记/","link":"","permalink":"http://yoursite.com/2018/07/15/《深入浅出NodeJS》读书笔记/","excerpt":"","text":"##第一章 Node Node：“一个强制不共享任何资源的单线程、单进程系统，通过协议构建不同的node来形成一个大型的网路应用，每一个node为一个节点”，这是书中给的解释原文 非阻塞I/O 书中多次提到的概念，我理解的非阻塞就是线程或进程的停止， 特点 1.异步 2.事件（随意绑定事件），时间绑定轻量级、松耦合 3.回调函数 Ajax请求：快速动态刷新网页，不刷新，直接更新参数 读完第一章以后，觉得云里雾里，这本书对于没有JS基础的人来说有点头疼。不过能肯定的是nodejs是一门异步I/O的语言，和python等编程习惯不一样，需要适应。 至此，我决定先啃《js高级程序设计第三版》这本书，对js有一定的了解以后再来学习nodejs。 ##第二章 C/S模式：客户/服务器模式，例如微信等B/S模式：浏览器/服务器模式，例如各种web应用 CommonJS规范： 相比于python的import，JAVA的类文件等，js是没有模块引入机制的，只能通过&lt;script&gt;标签这种杂乱的方式引入代码。在nodejs未出现之前，js只能用于前端，只有Rhino等后端javascript运行环境来作为小工具。node这么多年发展以来，已经形成了一套响应的规范，也就是CommonJS规范。 1.模块引用：var math = require(&#39;math&#39;); 2.模块定义：export.add = function(){...;return sum}; export.increment = function(val){}; 3.模块标识： node模块实现： node引入模块需要3个步骤：路径分析、文件定位、编译执行，其中系统自带的模块为核心模块，直接随node启动时加载进内存，加载速度快；用户自定义的模块称为文件模块，在运行时动态加载，慢。 1.路径分析：require(&#39;标识符&#39;)；//分析标识符，标识符主要分为： *核心模块，如http、fs、path等。 *.或..等相对路径文件模块 *以/开始的绝对路径文件模块 *非路径形式的文件模块，如自定义的connect模块 （自定义模块非核心模块和路径形式的模块，分析速度最慢） 2.文件定位： *扩展名分析：模块文件可以不带扩展名，自动按.js、.json、.node顺序补全。 *目标分析和包： 3.模块编译 *核心模块一般为C/C++或javascript编译，所有的都转换为C/C++然后编译 4.内建模块：全由C/C++编译的模块，使用： process.binding(&#39;标识符&#39;) 来进行导出 包与NPM： &quot;package.json&quot;：包含包的所有信息（版本、名称、作者等） NPM已经是一个包共享平台，实现第三方模块的发布、安装和依赖。 前后端共用模块： 前端规范：AMD规范、CMD规范 1.AMD规范定义的模块需要用define： define(function(){...}) 2.CMD规范申明时要指定所有的依赖 ##第三章","categories":[],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]}]}