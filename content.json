{"meta":{"title":"TedQin","subtitle":null,"description":"Output is the best input","author":"Ted Qin","url":"http://yoursite.com"},"pages":[{"title":"All categories","date":"2019-07-28T10:39:03.000Z","updated":"2019-07-28T17:41:00.655Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2019-07-25T07:40:02.000Z","updated":"2019-07-25T14:41:55.720Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"牛客网JavascriptV8输入格式","slug":"牛客网JavascriptV8输入格式","date":"2019-08-03T15:38:20.000Z","updated":"2019-08-03T22:42:28.094Z","comments":true,"path":"2019/08/03/牛客网JavascriptV8输入格式/","link":"","permalink":"http://yoursite.com/2019/08/03/牛客网JavascriptV8输入格式/","excerpt":"","text":"相比Leetcode，牛客和赛码网等网站对于Javascript真的太不友好了，光是输入就可以折腾半天。整理了一下牛客网上Javascript V8的输入 输入一行，空格隔开 1 2 while (line = readline()) { var lines = line.split(&#39; &#39;) var a = parseInt(lines[0]) var b = parseInt(lines[1]) } console.log(a, b) 多行，每行输入一个 2 1 2 var lines = [] while (line = readline()) { lines.push(parseInt(line)) } console.log(lines) 多行，第一行为参数,后面行为数组 //第一行为参数m和n，接下里为数组 2 3 //m, n 1 2 3 4 11 22 33 44 var lines = readline().split(&#39; &#39;) var n = parseInt(lines[0]) var m = parseInt(lines[1]) var Arr1 = readline().split(&#39; &#39;) var Arr2 = readline().split(&#39; &#39;) console.log(n,m,Arr1,Arr2)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"vue2.0仿去哪儿网移动端Webapp遇到的问题","slug":"vue2.0仿去哪儿网移动端Webapp遇到的问题","date":"2019-07-31T15:20:07.000Z","updated":"2019-08-01T02:52:01.197Z","comments":true,"path":"2019/07/31/vue2.0仿去哪儿网移动端Webapp遇到的问题/","link":"","permalink":"http://yoursite.com/2019/07/31/vue2.0仿去哪儿网移动端Webapp遇到的问题/","excerpt":"","text":"vue2.0仿去哪儿网移动端Webapp遇到的问题github地址：https://github.com/tedqin/Traveldemo：https://tedqin.github.io/Travel/ 使用vue2.0对去哪儿网的移动端web页面的复现，做个总结。 为什么使用单页面应用多页面应用 每次页面跳转，后端返回一个新的html 优点：首屏时间快、seo效果好（搜索引擎可以识别跳转的多个链接） 缺点：页面切换慢（每次跳转需发送http请求） 单页面应用 js感知路由变化，动态清除页面内容并将新页面渲染 优点：页面切换快 缺点：首屏时间慢，seo差 移动web端配置 使用rem单位 防止手指放大缩小页面，修改index.js &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 组件开发合理拆分组件，提高开发效率。父组件通过import方式导入子组件，并且 export default { name: &#39;xxx&#39;, components: {注册子组件名} 插槽使用场景：当组件的内容希望父组件去定制 stylusstyle库，增加开发效率。其中，.a &gt;&gt;&gt; .b具有穿透scoped限制的效果 防抖为了防止图片加载的过程中，页面抖动（图片未加载完毕的时候，文字会在上方，加载完毕后会抖动） .wrapper width: 100% height: 0 overflow: hidden padding-bottom: 26.7% //图片的宽高比 vuex进行非父子组件数据传递一般使用vuex中有几个关键：单向数据的改变过程state存放公用数据，组件改数据必须调用actions，做一些异步处理或者批量的同步操作。然后actions调用mutations，只有通过改变mutations的值才能改变state 在state中设置默认值 attr = &#39;aaa&#39; 在组件中通过dispatch向actions派发数据（如果没有异步请求，可以直接使用commit，跳过这步） this.$store.dispatch(&#39;actionsName&#39;, data) 在actions中通过commit向mutations发送数据 actionnName(tcx, data) { tcx.commit(&#39;mutationsName&#39;, data) } 然后在mutations中修改state中的值 mutationsName(state, data) { state.attr = data } 高级使用 引入mapState, mapMutations import [mapState, mapMutations] from &#39;vuex 把mapState添加到计算属性（compute）中，把mapMutations添加到方法（methods）中 computed: { ...mapState({ currentCity: &#39;city }) }, methods: { ...mapMutations( [&#39;changeCity&#39;] ) } axios发送ajax请求 使用生命周期函数mounted函数获取ajax数据，此时vue实例被挂载，但dom还没有渲染，可以节省性能 请求url：axios.get(&#39;xxx/xxx.json&#39;) axios返回的是promise对象，可以使用then methods: { getCityInfo () { axios.get(&#39;/Travel/static/mock/city.json&#39;) .then(this.handleGetCityInfoSucc) }, handleGetCityInfoSucc (res) { res = res.data if (res.ret &amp;&amp; res.data) { const data = res.data this.cities = data.cities this.hotCities = data.hotCities } ... 对以上代码的解释： 在mounted钩子函数里面定义一个A方法，只要页面加载完毕就执行A方法 A方法用于获取后端的数据，它是一个promise函数，只要获取到了函数就then一个B函数 B函数可以接收一个res参数，这个参数就是返回的结果 ajax请求一般放在最外层的组件，这样只需要一次请求就可以获取所有页面的内容 ajax获取动态数据 在路由里的地址后面写:id，表示把对应的id参数存在了id变量中 在获取ajax请求的地址上，可以写axios.get(&#39;xxx/xxx.json?id=&#39; + this.$route.params.id) 也可以写axios.get(&#39;xxx/xxx.json&#39;, {params: {id: this.$route.params.id}}) router-link vue中的内置路由组件 &lt;router-link to=&#39;/city&#39;&gt;&lt;/router-link&gt; 使用前先在router/index.js中配置路由 可以通过配置tag属性改成别的标签 单行内容超出范围当单行文字内容超出显示范围，而显示......时，可以 overflow: hidden white-space: nowrap text-overflow: ellipsis betterscroll页面滚动插件 函数节流当鼠标在字母表上来回移动的时候，touchMove执行的频率是非常高的，通过函数节流限制下执行的频率：增加延时器 localstorage自动缓存，刷新页面的时候已经选择的城市不发生改变 相当于cookie，但是用法要简单很多 用法： localStorage.arrt = va;ue 最好使用try catch包裹，因为在部分浏览器会报错 keepalive优化问题：缓存页面数据，防止切换页面会发生多次ajax请求 &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; 它的意思是，路由内容每被加载一次，就把路由中的内容放到内存之中，下一次再进这个路由的时候，不需要再次渲染这个组件去重新执行钩子函数，只需要你从内存把以前的内容拿出来显示到页面上就可以 组件中name属性 在递归组件时使用 keepalive取消缓存在exclude=’组件name’中使用 vue devtool调试工具中显示项目结构的名字 组件异步加载正常情况下，单页应用会在进入首页时加载所有组件可以删除import特定的组件，然后通过component: () =&gt; import(&#39;@/pages/home/Home)按需加载 全局事件解绑 window是全局事件，无论那个页面都会监听这个事件，会影响到其他页面，所以要解绑 在有keep-alive时会出现两个新的钩子函数： activated 在页面被显示时执行 deactivated 在页面即将被隐藏或页面被替换的时候执行 简写 @表示src目录 es6中，键值对相同写一个就可以 组件一览 home Header 头部 Icon 原型图标区域 Recommend 推荐 Swiper 图片轮播 Weekend 周末推荐 city Header 头部 Alphabet 右侧城市首字母下拉列表 List 城市列表 Search 搜索 detail Header 头部 Banner 主页面 List 图片详情页的轮播 部署到GitHub pages参考 https://medium.com/@Roli_Dori/deploy-vue-cli-3-project-to-github-pages-ebeda0705fbd webpack后期更新","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"javascript","slug":"前端/javascript","permalink":"http://yoursite.com/categories/前端/javascript/"},{"name":"vue","slug":"前端/javascript/vue","permalink":"http://yoursite.com/categories/前端/javascript/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"javascript整理","slug":"javascript整理","date":"2019-07-15T13:23:22.000Z","updated":"2019-09-21T01:16:20.864Z","comments":true,"path":"2019/07/15/javascript整理/","link":"","permalink":"http://yoursite.com/2019/07/15/javascript整理/","excerpt":"","text":"闲来无事，把之前的笔记整理一下。 基础知识变量类型 值类型：a和b相等，改a，b不变 (直接赋值值) undefined string number boolean 引用类型：a和b相等，改a，b变 （赋值地址） object function 强制类型转换 字符串拼接 var a=10; var b=100 + &#39;10&#39;//string == 100==&#39;100&#39;; 0==&#39;&#39;; null==undefined //true if if(b=100)//转换为true 逻辑运算符(&amp;，||) 10&amp;&amp;0；&#39;&#39;||&#39;abc&#39;; !window.abc//都转换为true或false 问题 typeof能得到哪些类型 number, string, object, boolean, function, undefiend, symbol （null是object） symbol： 可以生成永不重复的值，可以用一个字符串标记 何时使用===，何时使用== ===：内容相等数据类型也相同的严格模式；==：内容相等数据类型可以不相等 使用==的唯一情况：’’if(obj.a==null){}’’ 原型 原型链 构造函数 function Foo(name,age) {this.name=name; this.age=age return this} var f = new Foo(&#39;ted&#39;,20) var a ={}是var a =new Object()的语法糖//数组，函数同理 函数名大写字母开头 原型规则和示例 所有的引用类型（数组对象函数）都具有对象特性，即可自由扩展属性(null除外) 所有的引用类型都有一个__proto__属性，属性值是一个普通对象 所有的函数都有一个prototype属性，属性值也是一个普通的对象 __proto__对象指向它的构造函数的prototype对象（完全等于） 当试图得到一个引用类型的某个属性时，如果这个变量本身没有这个属性，那么会去它的__proto__，即它的构造函数的prototype中找 例子：不遍历原型上的属性：if(f.hasOwnProperty(item)) 原型链 一个对象，对象自身不存在的属性到它的隐式原型找，它的隐式原型不存的的话，再到它的隐式原型的隐式原型中找 Object.prototype指向null，防止死循环 instanceof instanceof判断一个函数是否是一个变量的构造函数 var f = new Foo(&#39;ted&#39;) f instanceof Foo//true 判断逻辑：f的__proto__一层层往上，能否对应到Foo.prototype 问题 如何准确判断一个变量是数组 var arr = [] arr instanceof Array//true 写一个原型链继承的例子 function Animal(){this.eat = function(){console.log(&#39;eat&#39;)}} function Dog(){this.bark(){console.log(&#39;bark&#39;)}} Dog.prototype=new Animal() var haski=new Dog() //这个比较low function Elem(id){this.elem=document.getElementById(id)} Elem.prototype.html=function(val) { var elem=this.elem if(val){ elem.innerHTML=val return this } else{ return elem.innerHTML}}&lt;/pre&gt; Elem.prototype.on=function(type,fn){ var elem=this.elem elem.addEventListener(type,fn) &lt;/pre&gt; var div1 = new Elem(&#39;div1&#39;) 描述new一个对象的过程 创建一个新对象 this指向这个新对象 执行构造函数的代码，即对this赋值 返回this 作用域 闭包 执行上下文 代码执行的环境 一段&lt;script&gt;：全局上下文 变量定义-&gt;函数申明 一个函数：函数上下文 变量定义-&gt;函数申明-&gt;this-&gt;arguments this this要在执行时才能确认值，定义时无法确认 call可以改变this的值：a.fn.call({name:B}) 1.作为构造函数执行：指向定义的对象 function Foo(name) {this.name = name}var f = new Foo(‘ted’) 2.作为对象属性执行:指向该对象 var obj = {name: ‘A’, printName: function () {console.log(this.name)}}obj.printName() 3.作为普通函数执行: 指向window function fn() {console.log(this)}} 4.call apply bind function fn1(name, age) {alert(name); console.log(this)}fn1(‘ted’,20)//普通函数的this，指向windowfn1.call({x:100},’ted’,20)//通过call函数改变this，指向{x:100}这个对象fn1.apply({x:200}, [‘ted’, 20])//apply和call不同在于参数用数组传递 //bind:适用于函数表达式 var fn2 = function (name, age) { alert(name); console.log(this)} .bind({y:300}) fn2('ted',20)//通过bind函数改变this，this也指向{y:300}这个对象 作用域 JS没有块级作用域 在函数中定义和赋值的变量可以在函数外使用 ES6中加入块级作用域：for(let i = 0; i&lt; 10; i++){}console.log(i)//报错，let定义的变量有块级作用域，在for中定义的不能在for之外访问 JS有函数和全局作用域 定义在函数中的变量，只能在函数中修改 自由变量：当前作用域没有定义的变量，可以在父级作用域中去找 作用域链 当前作用域可访问父级作用域 一个元素的父级作用域是在它定义的时候的作用域，而非执行 闭包 函数作为返回值 函数作为参数传递 闭包中返回的函数，若有自由变量，则向（函数定义时）父作用域寻找 问题 说一下对变量提升的理解 在各个执行上下文中，变量定义+函数声明都会提前 说明this几种不同的使用场景 作为构造函数：指向定义的对象 作为对象属性：指向该对象 作为普通函数：指向window call apply bind： 指向改变的对象 创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号 * 如何理解作用域 自由变量 作用域链，自由变量的查找 闭包的两个场景 闭包 实际开发中闭包的应用 封装变量，收敛权限 let isFirstLoad = function () { let _list = [] return function (el) { if (_list.indexOf(el) &gt;= 0) { return false } else { _list.push(el) return true } } } let firstLoad = isFirstLoad() isFirstLoad(10) //true isFirstLoad(10) //false isFirstLoad(20) //true 异步和单线程 什么是异步（对比同步） 同步会阻塞，异步不会，遇到setTimeout会先执行后面的代码 何时使用：有可能发生等待的情况-等待的过程不能阻塞程序运行 前端使用异步的场景 定时任务：setTimeout，setInverral 网络请求：ajax请求，动态加载 （时间不固定） 事件绑定：如点击事件，在不点击的时候不能阻塞程序运行 异步和单线程 单线程：代码一个个排队执行，不能同时干两件事 js是单线程，所以在遇到阻塞的情况，要用异步，现将不需要等待的代码执行完，再执行异步代码 问题 同步和异步的区别是什么？分别举一个同步和异步的例子 同步会阻塞代码，异步不会，alert是同步，setTimeout是异步 一个关于setTimeout的笔试题 前端使用异步的场景有哪些？ 定时任务-网络请求-时间绑定 补充 日期 Date.now() //获取时间戳 //2019/09/17/23:41:44 let dt = new Date() dt.getTime() //获取时间戳 dt.getFullYear() //2019 dt.getMonth() //8 (0-11) dt.getDate() //17 (0-31) dt.getHours() //23 (0-23) dt.getMinutes() //41 (0-59) dt.getSeconds() //44 (0-59) Math 获取随机数Math.random() 数组api forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否有至少一个元素符合条件 sort 排序 map 对元素重新组装，生成新数组 filter 过滤符合条件的元素 对象api for in 题目 获取2019-07-25格式的日期 let formatDate = function (dt) { if (!dt) { dt = new Date() } let year = dt.getFullYear() let month = dt.getMonth() + 1 let date = dt.getDate() if (month &lt; 10) { month = &#39;0&#39; + month } if (date &lt; 10) { date = &#39;0&#39; + date } return year + &#39;-&#39; + month + &#39;-&#39; + date } let dt = new Date() console.log(formatDate(dt)) 获取随机数，要求是长度一致的字符串格式 //获取长度一致的随机数 let formatRandom = function () { let random = Math.random() random = random + &#39;0000000000&#39; return random.slice(0, 10) } console.log(formatRandom()) JS API JS语法标准（基础知识）：ECMA 262标准 JS-WEB-API（浏览器）：W3C标准 DOM操作 BOM操作：浏览器操作 获取当前地址 获取屏幕尺寸 事件绑定 AJAX请求（包括http协议） 存储 没有规定任何JS基础相关的东西 全面考虑，JS内置的全局函数和对象（浏览器打造） Object，Array，Boolean等 window document 所有未定义的全局变量，如navigator.userAgent DOM操作 DOM本质 浏览器拿到html代码后，把html结构化成浏览器可识别以及js可识别的东西，就是dom dom本质是js的对象 DOM节点操作 获取dom节点 //获取DOM节点 //get let id1 = document.getElementById(&#39;id1&#39;) //id let divs = document.getElementByTagName(&#39;div&#39;) //元素集合 let div0 = document.getElementByTagName(&#39;div&#39;)[0] //元素 let classes = document.getElementsByClassName(&#39;class1&#39;) //class集合 let class0 = document.getElementsByClassName(&#39;class1&#39;)[0] //class //query let id1 = document.querySelector(&#39;#id1&#39;) //id let divs = document.querySelectorAll(&#39;div&#39;) //元素集合 let div0 = document.querySelector(&#39;div&#39;) //元素，选择第一个div let div0 = document.querySelector(&#39;div&#39;)[0] //元素，选择第一个div let classes = document.querySelectorAll(&#39;.class0&#39;) //class集合 let class0 = document.querySelector(&#39;class0&#39;) //class，选择第一个class let class0 = document.querySelector(&#39;class0&#39;)[0] //class，选择第一个class property js对象中的属性 //获取attribute let p0 = document.quertSelectorAll(&#39;p&#39;)[0] console.log(p0.style.width) //获取样式 p0.style.width = &#39;200px&#39; //修改样式 console.log(p0.className) //获取class p0.className = &#39;p0&#39; //修改class console.log(p0.nodeName) //p console.log(p0.nodeType) //1 attribute HTML文档中 标签的属性 //获取attribute let p0 = document.querySelectorAll(&#39;p&#39;)[0] p0.getAttribute(&#39;attr1&#39;) //获取p0上的attr1属性的值 p0.getAttribute(&#39;attr1&#39;, &#39;abc&#39;) //修改属性 p0.getAttribute(&#39;style&#39;) //获取style，元素上必须有style才行 p0.getAttribute(&#39;style&#39;, &#39;font-size:30px&#39;) DOM结构操作 新增节点 document.createElement(node) //添加新节点 let div1 = document.getElementById(&#39;div1&#39;) let p1 = documemt.createElement(&#39;p&#39;) div1.appendChild(div1) //移动现有节点 let p2 = document.getElementById(&#39;p2&#39;) div1.appendChild(p2) 获取父节点 childNode.parentElement let div1 = getElementById(div1) let parent = div1.parentElement 获取子节点 .parentNode.childNodes let div1 = getElementById(div1) let parent = div1.parentElement .childNodes返回所有节点包括文本和注释节点 .children只返回元素节点 删除节点 parentNode.removeChild(childNode) let div1 = getElementById(div1) let child = div1.childNodes //删除第一个子元素 div1.removeChild(child[0]) 问题 DOM是哪一种基本数据结构 数 DOM操作的常用API有哪些 获取DOM节点，以及节点的property和attr 获取父节点，子节点 新增，删除，移动节点 DOM节点的attr和property有何局别 property是js属性的修改和获取 attr是对html标签的修改和获取 BOM操作 navigator浏览器 判断浏览器类型 userAgent var ua = navigator.userAgentvar isChrome = ua.indexOf(‘Chrome’)console.log(isChrome) screen屏幕 console.log(screen.width) console.log(screen.height) location地址栏信息 拆解url location.href //url location.protocal //协议 http https location.host //域名 location.pathname //路径 /learn/199 location.search //url ？ 后面的字符串 location.search //url # 后的hash history历史 前进后退 history.back history.forward 问题 如何检测目标浏览器的类型 let ua = navigator.userAgent let isChrome = ua.indexOf(&#39;Chrome&#39;) console.log(isChrome) 拆解url的各部分 location.href //url location.protocal //协议 http https location.host //域名 location.pathname //路径 /learn/199 location.search //url ？ 后面的字符串 location.search //url # 后的hash Ajax XMLHttpRequest let xhr = new XMLHttpRequest() xhr.open(&quot;GET&quot;, &quot;/api&quot;, &quot;false&quot;) xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status === 200) { alert(xhr.responseText) } } } xhr.send(null) 状态码说明 readyState == 4 ajax状态码 0-（未初始化）还没有调用send()方法 1-（载入）已调用send()方法，正在发送请求 2-（载入完成）send()方法执行完成，已经接收到全部响应内容 3-（交互）正在解析响应内容 4-（完成）响应内容解析完成，可以在客户端调用了 statue == 200 http标准状态码 2xx - 表示成功处理请求。如200 3xx - 需要重定向，浏览器直接跳转 4xx - 客户端请求错误，如404 5xx - 服务端错误 跨域 什么是跨域 浏览器有同源策略，不允许ajax访问其他接口，如http://www.a.com:80不能访问http://www.b.com 跨域条件：协议(http)、域名(www.a.com)、端口(:80)有一个不同就算跨域 可以跨域的三个标签 &lt;img src=xxx&gt; 用于打点统计，统计网站可能是其他域 &lt;link href=xxx&gt; 可以使用CDN，CDN也是其他域 &lt;script src=xxx&gt; 可以使用CDN，CDN也是其他域 可以用于JSONP JSONP 前端 &lt;!-- jsonp跨域 --&gt; &lt;script&gt; function callbackFunc (data) { alert(data) } &lt;/script&gt; &lt;script src=&quot;http://www.baidu.com/api/data.js&quot;&gt;&lt;/script&gt; 前端定义一个callback函数，得到信息。再用script标签获取一个跨域的信息，这个信息会调用callback({x:100, y:200}) 服务器端设置http header 后端 //后端通过设置httpheader跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://a.com, http://b.com&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT, POST,GET, OPTIONS, DELETE&quot;); //允许接收跨域的cookie response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); 问题 手动编写一个ajax，不依赖第三方库 前面有 跨域的几种实现方式 JSONP 服务器端设置http header 事件绑定 通用事件绑定 //通用事件绑定函数 function bindEvent (elem, type, fn) { elem.addEventListener(type, fn) } let a1 = document.getElementById(&#39;a1&#39;) bindEvent(a1, &#39;click&#39;, function (e) { e.preventDefault() alert(&#39;clicked&#39;) }) 事件冒泡 若底层和父层节点有相同绑定事件，底层业务节点的事件（如点击）会先执行，然后会一层层网上执行，先执行底层的事件，然后上一层的事件，然后… 点击激活弹出激活，点击取消弹出取消（e.stopPropatation()：阻止冒泡） 代理 事件冒泡的应用 点击a标签的元素，会弹出相应文字 ` &lt;!DOCTYPE html&gt; propogation a1 a2 a3 a4 let div1 = document.getElementById(“div1”) div1.addEventListener(“click”, function(e) { alert(e.target.innerHTML) }) ``` （这里target可以定位到当前点击的元素） 问题 编写一个通用的事件监听函数 描述事件冒泡流程 dom树形结构 冒泡 阻止冒泡 应用：代理 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 使用代理：代码简洁，对浏览器压力小 存储 cookie 属于http的东西，本身用于客户端和服务端通信 但是它有本地存储的功能，于是被“借用” 使用document.cookie=...获取和修改即可 限制： 存储量太小，只有4kb 所有http请求都带着，会影响获取资源的效率 API简单，需要封装才能用document.coockie sessionStorage和localStorage H5专门为存储而设计，最大容量5M API简单易用,key+value localStorage.setItem(key,value) localStorage.getItem(key) 问题 描述一下cookie（h5之前），sessionStorage和localStorage的区别 cookie和后两者的区别 容量 是否会携带到ajax请求中 API易用性 后两者的区别 localStorage不会主动删除，sessionStorage随着每次会话结束会清除，95%的场景存储到localStorage中 开发环境IDE（写代码的效率） webstorm sublime vscode atom git 版本管理，多人协作 常用命令 git add . git checkout xxx git commit -m ‘xxx’ //提交到本地仓库 git push origin master git pull origin master git branch git checkout -b xxx git merge xxx js模块化 不适用模块化的情况 如果a.js, b.js, c.js, c依赖b，b依赖a，引用的时候必须要按顺序，如果顺序错就会报错 引用的文件的变量必须是全局变量，容易被污染 使用模块化 a.js 传递出别人所需要的功能函数，b和a需要哪个函数引用哪个函数 引用的时候直接引用最表层的js文件即可 AMD 异步模块定义规范 require.js 全局define函数 全局require函数 依赖的js会自动、异步加载 ` //util.js define(function() { return { func: function () { return 1 } } }) //a-utils.js define([‘./utils.js’], function(util) { return { func2: function () { return util.func() } } }) ``` * html用：``&lt;script src=&quot;/require.js&quot; data-main=&quot;./main.js&quot;&gt;&lt;/script&gt; `` * 好处：异步加载，不使用（依赖）就不加载 CommonJs nodejs模块化规划，现在被大量用于前端 前端开发依赖的插件和库，都可以用npm中获取 构建工具的高度自动化，使得使用npm的成本非常低 CommonJS不会异步加载js，而是同步一次性加载出来 //util.js module.exports = { func: function () { return 1 } } //a-util.js let util = require(&#39;./util.js&#39;) module.exports = { func2: function () { return utils() } } AMD和CommonJS的使用场景 需要异步加载，用AMD 使用了npm之后建议使用CommonJs 打包工具 webpack 启动一个服务，先全局安装，npm install http-server =g，然后在要访问的页面根目录启动服务 http-server 8080 npm init 初始化，完成后多处package.json文件 npm install webpack --save -dev 安装webpack 配置webpack 创建webpack.config.js var path = require(&#39;path&#39;) var webpack = require(&#39;require&#39;) module.exports = { context: path.resolve(__dirname, &#39;./src&#39;), extry: { app: &#39;./app.js&#39; }. output: { path: path.resolve(__dirname, &#39;./dist&#39;) filename: &#39;bundle.js&#39; } } 创建src app.js等文件 在package.json scripts里加入”start”: “webpack”，就可以在命令行执行start进行打包输出 webpack进行代码压缩： 在config的exports中追加plugins: [new webpack.optimize.UglifyJsPlugin()] webpack的主要作用： 代码合并：合并commonjs的语法规范，否则前端无法识别 代码压缩：保证代码上线 上线回滚的流程 上线的基本流程 将测试完成的代码提交到git版本库的master分支 将当前服务器的代码全部打包并记录版本号，备份 将master分支的代码提交覆盖到线上服务器，生成新版本号 回滚的基本流程 将当前服务器的代码全部打包并记录版本号，备份 将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号 linux基本命令 mkdir ls ll 列表形式的ls pwd cd cd .. rm -rf 文件夹名 //删除当前目录下所有文件 vi a.js //创建并进入a.js i //insert : //最下行 w //写 q //退出 cp a1 a2 //创建a2，把a1复制到a2 mv a1 f1 //把a1移动到f1文件夹 cat a1 //查看当前文件 grep ‘2’ a.js //查找a.js中的2 运行环境页面加载过程 加载资源的形式 输入url(或跳转页面)加载html 加载html中的静态资源 如&lt;script&gt;&lt;img&gt; 加载一个资源的过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到、处理并返回http请求（图片，html js代码，） 浏览器得到返回的请求并渲染 浏览器渲染页面的过程 根据HTNL结构生成DOM树 根据CSS生成CSSOM（结构化处理） 将DOM和CSSOM整合成RenderTree（渲染树，每个节点都规定了样式） 根据RenderTree开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 题目 从输入url到得到html的详细过程 根据DNS得到域名IP-向该IP发送请求-服务器收到处理返回请求-浏览器得到返回内容 window.onload和DOMCotentLoaded的区别 onload：页面全部资源加载完，包括图片视频等才会执行 CotentLoaded：DOM渲染完即可执行，图片还没有加载完 为什么把css文件放在head中？ 因为渲染默认是顺序的，保证在渲染body时候浏览器已经知道对应的样式了 为什么把js放在body最下面？ 不会阻塞之前body中html的渲染 保证script能拿到所有的html节点标签 性能优化 基本2点 多使用内存、缓存或者其他方法 -开源 减少CPU计算、减少网络 -节流 加载资源优化 静态资源的压缩合并 合并：将多个js文件合并成一个js 压缩：压缩体积 静态资源缓存 通过连接名称，名称不变的话，浏览器会加载之前同名的缓存 使用CDN让资源加载更快 不同区域的网络优化，上海转到上海的节点等等 使用SSR后端渲染，数据直接输出到HTML中（不同ajax请求数据） 页面渲染优化 CSS放前面，JS放后面 懒加载（图片懒加载，下拉加载更多/先用一张模糊的图片代替原图，要用的时候再加载） 什么时候用什么时候加载 减少DOM查询，对DOM查询做缓存 减少DOM操作，多个操作尽量合并在一个执行 先创建一个片段frag=document.createDocumentFragment() 事件节流 间隔一段时间执行一次 如键盘输入，在ns内执行一次事件, 不停的输入，也会在一段时间后输出一次 //时间戳版 function throttle(fn, delay) { let previous = 0 return function (args) { let _args = args let _this = this let now = Date.now() if (now-previous &gt; wait) { fn.call(_this, _args) previous = now } } } 事件防抖 超过一段时间不输入，执行一次 防止输入一个就输出一个这样的抖动情况，设置一个延迟，超过这个延迟不执行输入的情况下，才会执行输出。也就是输入一堆，停5ms不输入以后，才会输出 function debounce (fn, delay) { let timeout return function (args) { let _this = this let _args = args clearTimeout(timeout) timout = setTimeout(function (_args, _this) { fn.call(_this, _args) }, delay) } } //使用防抖 function print (content) { console.log(content) } let input = document.getElementById(&#39;text&#39;) let debounceInput = debounce(print, 100) input.addEventListener(&#39;keyup&#39;, function () { debounceAjax(e.target.innerHTML) }) 尽早执行操作（DOMCotentLoaded） 安全性 XSS跨站请求攻击 新浪博客写一篇文章，同时偷偷插入一段攻击代码&lt;script&gt; 攻击代码中，获取查看者的cookie，发送到自己的服务器 XSS预防 前端替换关键字，例如替换&lt;为&amp;lt；&gt;为&amp;gt 后端替换 XSRF跨站请求伪造 你已登录一个购物网站，正在浏览商品 付费接口是xxx.com/pay?id=100但是没有任何验证 你收到一封钓鱼邮件，隐藏着&lt;img src=&#39;xxx.com/pay?id=100&#39;&gt; 查看邮件的时候，就悄悄付费了 XSRF预防 增加验证流程，如输入指纹、密码、短信验证码 问题 前端安全问题的场景有哪些 面试技巧 简历 简介明了，重点突出项目经历和解决方案 把个人博客放在简历中，并且定期维护更新博客 把个人的开源项目放在简历中，并维护开源项目 不能造假，要保证能力和经历上的造假 谈谈你的缺点 说一下最近正在学的东西，比如我对vue不是很了解，正在学vue.js 面试题 window.onload和DOMCotentLoaded的区别 onload事件触发：页面上所有dom，样式表，脚本，图片，flash都已经加载完；DOMCotentLoaded：仅dom加载完 如何理解JSON 是一个JS对象，有两个API： JSON.stringify(obj)//将js的对象转换成json字符串 JSON.parse(&#39;{&quot;a&quot;:5}&#39;)//json字符串转js对象 是一个数据格式 js有哪些内置函数 Object Array Boolean Number String Function(以上为构造函数) Date RegExp Error promise一种异步解决方案，类似一个容器，包括未来会执行的任务 .then()参数1为resolve的内容，参数2（可以不要）为reject的内容 .catch()用于resolve有错误的情况，一般用在.then的最后 .finally()用于不管promise最后状态如何都执行的操作 .all()用于将多个promise包装成一个const p = Promise.all([p1, p2, p3]); 必须等三个都resolve，p才resolve，而有一个reject p就reject 场景：几个任务时间不一样，需要等全部完成才执行下一个任务 .race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。const p = Promise.race([p1, p2, p3]) 只要有一个resolve了，就算完成 场景：把异步操作和定时器绑定，如果定时到了异步操作还没完成就报错 .resolve()将对象转换为promise对象，状态为resolvelet jsPromise = Promise.resolve(para) param： promise对象，直接返回不做修改 thenable对象：有then: function(resolve, reject){resolve()}的对象，直接封装，立即执行then 普通对象：直接封装，状态为resolve.reject()将对象转换为promise对象，状态为reject .try()模拟try代码块","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"javascript","slug":"前端/javascript","permalink":"http://yoursite.com/categories/前端/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"DCGAN进行图像修复","slug":"DCGAN进行图像修复","date":"2019-07-10T04:12:51.000Z","updated":"2019-09-19T09:33:02.161Z","comments":true,"path":"2019/07/10/DCGAN进行图像修复/","link":"","permalink":"http://yoursite.com/2019/07/10/DCGAN进行图像修复/","excerpt":"","text":"本文已置于https://github.com/tedqin/GAN-ImageRepairing 总体设计 和典型的使用神经网络来实现目的方法一样，简单来讲，基于DCGAN的图像修复首先需要先训练出一组优秀的生成器和判别器，然后利用这一组训练好的模型进行图像修复。首先第一步需要进行图像预处理，这是因为DCGAN的模型结构决定了图像的尺寸大小是64”×” 64”×” 3，进行图像预处理之后，由于神经网络需要矩阵形式的输入，所以修复流程的首要步骤就是将图像分解为样本点，这个步骤可以由判别器的卷积实现，然后生成器和判别器进行博弈，得到训练好的模型，由生成器快速生成伪造的图像，然后建立适当的损失函数和惩罚因子来寻找修复图像所需要的最佳伪造图像。由此，总的系统流程主要可以分为三步： 图像预处理。 训练DCGAN模型。 找到补全原图像所需要的最佳伪造图像，进行图像修复。 图像预处理Openface预处理Openface是一个基于深度神经网络的开源人脸识别系统。 用OpenCV或者dlib中预训练好的模型检测人脸 将人脸迁移到神经网络。利用dlib的实时姿态估计与OpenCV的仿射线变换来使人脸的眼睛和嘴唇出现在每个图像上的相同位置。 使用深度神经网络将面部表示（或嵌入）在128维单位超球面上。这种嵌入方法可以通用于任何人脸表示上面。与其他的一些人脸表征方法不同，这种人脸嵌入方法具有很好的性质，两个嵌入人脸间的距离较大就意味着这两幅面孔可能不是来自于同一个人。 运用Openface来消除除了人脸外的其他的因素，比如背景、发型等等，然后移动图像，使得数据集中的每个人的人脸区域居于整张图片的中央。 构建掩膜为了能够评估修复结果，需要知道被损坏图像之前的样子。我采用给未损坏图像一个二进制掩膜来作为损坏区域，这样就可以在修复掩膜之后，对比修复前的图像进行修复效果评估。 训练 训练过程中，定义了一个采样器，在每一个epoch训练完成以后，用采样器对生成器进行采样并且保存样例图像 在20个epoch训练完成以后，生成的图像效果已经比较好，此时生成器和判别器的损失函数变化如图 修复部分结果如下：","categories":[{"name":"machine learning","slug":"machine-learning","permalink":"http://yoursite.com/categories/machine-learning/"},{"name":"gan","slug":"machine-learning/gan","permalink":"http://yoursite.com/categories/machine-learning/gan/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://yoursite.com/tags/machine-learning/"}]},{"title":"知识整理CSS","slug":"知识整理css","date":"2019-06-01T08:19:02.000Z","updated":"2019-09-19T08:53:07.692Z","comments":true,"path":"2019/06/01/知识整理css/","link":"","permalink":"http://yoursite.com/2019/06/01/知识整理css/","excerpt":"","text":"CSS选择器标签：p{}class: .class{}同一类，不同标签： p.class{}同一标签，多个类：p.class1{} .class2{id：#id {}集体选择器：p,.class1,#id1 {}后代选择器：&lt;p&gt;&lt;em&gt;&lt;a&gt;123&lt;a&gt;&lt;/em&gt;&lt;/p&gt;:p em a {}链接伪类 :link:未访问的链接 :visited：已访问的链接 :hover：鼠标悬停状态 :active：鼠标点击到松开的阶段（hover和active可用于任何标签）权重：id &gt; 类 属性 伪类 &gt; 元素 伪元素 &gt; 其他 字体大小文字粗细：font-weight: normal/bold文字斜度：font-style: normal/italic/oblique文字粗细：font-weight: 600 装饰器属性字重（粗体）font-weight斜体 font-style下划线 text-decoration指针 cursor 文本对齐方式文本水平对齐方式：text-align: left/right/center/justify左对齐/右对齐/居中对齐/两端对齐 只对块级元素有效 行高首行缩进：text-indent: 2em行高：line-height: 120em 最好用em防止字体过大导致显示不全注意：图片是按照inline元素做的排版，会涉及字体对齐，默认按照baseline对齐，和底线有空隙。 为了删除这个空隙，可以直接vertical-align: bottom或者display: block 滚动overflow 元素内容的垂直方式只对行内元素有效vertical-align: sub/supper/文字向上向下对齐 盒子模型 height：长度/百分比/auto width： border边框 边框粗细border-(top/l/r/bottom)-width: thin/medium/thick/长度值 边框颜色 border-color: 样式border-style: none/solid实线/dotted点状 简写: 粗细-样式-颜色 padding内边距 主要用来设置空隙 盒子与边框的距离 padding粗细padding-(top/l/r/bottom): thin/medium/thick/长度值 padding粗细简写：全/上下 左右/上 左右 下/上 右 下 左 margin外边距 边框与外界的距离 可以为负值 设置为auto：实现水平方向居中 display属性将元素显示为内联元素: inline将元素显示为块级元素: block将元素显示为内联元素具有快级属性可以设置宽高: inline-block ps：宽高设为100%，表示和父元素相同 浮动 脱离文档流，只能左右 float:left/right/none 浮动后出现的问题： 浮动溢出（高度塌陷） 解决：清楚浮动 clear:none/left/right/both 1.&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 2.给父元素添加overflow:hidden 3.css3 clearfix :after 4.添加一个空行，style为clearboth {content:”.”;display:block;height:0;visibility:hidden;clear:both} 可以让行内元素行程块级元素 位置会尽量靠上，尽量靠左 position 定位模型 static：常规流 忽略跑偏移量 relative： 相对常规流，设置偏移量 top/bottom/left/right:10px 常规流的位置会留下，不会影响其他元素 absolute：绝对定位 相对于最近的祖先元素做绝对定位 常规流的位置会被占据，会影响其他元素 如果设置上下左右偏移量为0，margin：autoauto，子元素就会相对于父元素居中 常用： 父元素设置为relative，子元素设置为absolute，子元素就可以设置相对于父元素的偏移量 fixed：相对定位 不会随着视图滚动而滚动，其余和absolute一样 后三者可以设置z-index CSS3 新增的元素选择器 子元素选择器：father &gt; son1 {} 相邻兄弟元素选择器:father &gt; son1 + son2 {} 通用兄弟选择器: father &gt; son1 ~ son5 {} 群组选择器: father &gt; son1, father &gt; son2, father &gt; son3 {} 属性选择器 a[href] {} 伪类选择器 动态伪类（之前有）： 锚点伪类 a:link{} a:visited{} 用户行为伪类 :hover :active :focus UI元素状态伪类 input:enabled {} :disabled :checked 结构类选择器 first/last子类选择器section:fi&lt;div class=&quot;a2&quot;&gt;123 &lt;/div&gt;&lt;div class=&quot;a2&quot;&gt;123 &lt;/div&gt;&lt;div class=&quot;a2&quot;&gt;123 &lt;/div&gt;&lt;div class=&quot;a2&quot;&gt;123 &lt;/div&gt;rst-child {} 父元素的第N个子元素ul&gt;li:nth-child(3){} 选择多个： nth-child(n){} 边框与圆角 圆角 border-radius:10px/10rem/10% 盒阴影 box-shadow:水平偏移 垂直偏移 模糊 扩展 颜色 边界图片 border-image:source 文本 文本阴影 text-shadow:h v blur color 自动换行 word-break 文本属性 字体 @font-face @font-face {font-familt:&lt;name&gt; src:&lt;source&gt; [&lt;format&gt;]} transform 转换 旋转transform:rotate(&lt;angle&gt;) 平移trandform:translate(x,y) trandform:translateX(200px) trandform:translateY(200px) 缩放：水平 垂直 都有 trandform:scaleX(.5) 扭曲: 三种 skewX(&lt;angle&gt;)`` 3D transform rotateX translate3d(x,y,z) scale3d(x,y,z) scaleZ(z) 动画 transition 补间动画 两个状态 keyframe 关键帧动画 有很多状态 逐帧动画 没有补间 常用布局方式表格布局 &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;left&quot;&gt;left&lt;/td&gt; &lt;td class=&quot;right&quot;&gt;right&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; float+margin &lt;style&gt; .container { width: 500px; height: 500px; } .left { width: 100px; height: 100%; float: left; background: green; } .middle { margin-left: 100px; /*空出和左边width一样*/ margin-right: 200px; /*空出和右边width一样*/ background: #000 } .right { height: 100%; width: 200px; float: right; background: yellow; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;!--先写right，right写在最后会因为float上靠--&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; inline-block 像文本一样排block元素 问题:中间有间隙： 解决方法：把父元素字体大小设为0，并在子元素中设置字体大小 &lt;style&gt; .container { width: 500px; height: 500px; } .left { width: 100px; height: 100%; display: inline-block; background: green; } .right { height: 100%; width: 200px; display: inline-block; background: yellow; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; flexbox &lt;style&gt; .a1 { display: flex; height:100px; width: 500px; background: #000 } .a2 { flex: 1; background: red } &lt;/style&gt; &lt;div class=&quot;a1&quot;&gt; &lt;div class=&quot;a2&quot;&gt;123 &lt;/div&gt; &lt;/div&gt; 响应式设计和布局 主要考虑屏幕大小 主要方法： 隐藏：隐藏导航栏等不重要的东西 折行：pc端一行显示多个的在移动端一行显示少一些 自适应空间：多留出自适应空间 方式： rem：通过html的字体大小确定元素大小 html默认的样式字体大小为16px，1rem=16px，不同屏幕在mediaquery中改html的字体大小即 viewport：在meta中手工确定屏幕大小content=&quot;width=320&quot; media query：为不同屏幕写样式 @media (max-width: 640px) { .left{display: none} /*为移动端隐藏样式*/ } css问题 css优先级 权重：id&gt;class&gt;tag !important: 最高 内联样式高 后写的优先级高 伪类和伪元素的区别 伪类表状态 hoover等 伪元素是真的元素 before after 在页面中会显示 前者单冒号 后者双冒号 实现两栏（三栏）布局的方法 表格布局 float+margin 清楚浮动 inline-block 处理间隙 flexbox 兼容性差 absolute和fix有什么区别 absolute相对于最近的absolute/relative来定位 fix相对于屏幕/viewport定位 inlineblock为什么有间隙 空白字符 解决：消灭字符；父元素字体设为0 清除浮动 为什么有浮动：浮动的元素不会占据父元素的布局空间，父元素不会管浮动元素，所以可能会高度塌陷 清除：给父元素加定高宽；父元素加overflowhidden；给父元素加:after{clearboth}；最后加一行空行clearboth 如何适配移动端页面 viewport rem/viewport/media query 设计上：隐藏/折行/自适应visibility: hidden;display: block;font-size: 0;content: “ “;clear: both;height: 0; 关于html的一些补充h5新增标签 新区块标签 section article anv 导航 aside 侧边栏，一般表示不重要的内容 表单增强属性 日期、时间、搜索 表单验证 （required必填，minmax输入范围，正则） placeholder 表单空的时候显示什么内容 自动聚焦 新增语义 header/footer section/article 区域 nav 导航 aside em/strong 强调 嵌套 块级一般不能嵌套块级（但div可以嵌套p） a可以包含div html问题 doctype的意义是什么 让浏览器以标准模式渲染 让浏览器知道元素的合法性 html xhtml h5的关系 html属于sgml xhtml属于xml，是html进行xml严格化的结果 h5是一个独立的规范，比hxtml宽松 H5有什么变化 新的语义化元素section article header footer aside 表单增强 新的API em和i有什么区别 都是斜体，em是语义化标签，i是纯样式 语义化的意义 维护的开发者容易理解 机器容易理解结构 有助于seo 哪些标签可以自闭和（不能嵌套其他标签） input img br（换行） hr（水平线） meta link","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"css","slug":"前端/css","permalink":"http://yoursite.com/categories/前端/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Alexnet图像分类","slug":"Alexnet图像分类","date":"2019-05-22T13:12:11.000Z","updated":"2019-09-19T09:45:17.230Z","comments":true,"path":"2019/05/22/Alexnet图像分类/","link":"","permalink":"http://yoursite.com/2019/05/22/Alexnet图像分类/","excerpt":"","text":"github链接：https://github.com/tedqin/Alexnet_Imagenet 背景 概述 Alexnet是Hinton小组在ImageNet图像处理大赛ISVRC2012中使用的神经网络模型，并获得了第一名，测试错误率相比往年的第一名都有大幅度的提升，top5测试错误率是15.3%，第二名是26.2%。Alexnet有60M个参数，650,000个神经元，5个卷积层和3个全连接层（1000类的softmax分类器）。Alexnet模型由Alex Krizhevsky 等人在两个GTX 580 3GB GPU上训练5、6天左右得到。目前是深度学习图像处理领域当中最常用的模型之一。AlexNet相比于以前的一些网络模型来说，做出了很多创新，主要包括以下几点 框架 使用激活函数ReLu 多GPU并行训练 局部影响标准化 重叠池化 模型结构Alexnet有5个卷积层和3个全连接层，并且Alex发现移除任意一层都会降低最终的效果。网络结构如图 这个网络前面5层是卷积层，后面三层是全连接层，最终softmax输出是1000类。 第三卷积层用384个33256的卷积核,得到1313192*2的卷积层。 第四卷积层用384个33192的卷积核，得到1313192*2的卷积层。 第五卷积层用256个33192的卷积核，得到1313128*2的卷积层。每个全连接层有4096个神经元。 总体而言，Alexnet网络的结构如下： 数据集 测试caffe提供的预训练模型一共包括了1000类图像，涵盖了生物、天文、自然、科技等多个方面的相关图像，具体在caffe_classes.py下，由于文件本身较大就没放在github上，可以很容易在网上找到测试集包括1000张图像，共200类，标签存储在lable.txt当中。取测试图像概率最大类的下标作为测试的分类结果（即top-1测试），并且与label对比，最后计算得出整个测试集得precision在75%左右，算是比较好的结果。 总结AlexNet可以说是深度神经网络的鼻祖，相比于后来的VGG和googlenet而言，它的构造更加简单，而且结构也已经非常的成熟和稳固。作为学校的大创项目用alexnet有点蠢，但是时间紧迫，也分享下自己学习cnn的过程。","categories":[{"name":"machine learning","slug":"machine-learning","permalink":"http://yoursite.com/categories/machine-learning/"},{"name":"cnn","slug":"machine-learning/cnn","permalink":"http://yoursite.com/categories/machine-learning/cnn/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://yoursite.com/tags/machine-learning/"}]},{"title":"面试总结和知识梳理","slug":"面试总结和知识梳理","date":"2019-04-17T02:29:13.000Z","updated":"2019-07-28T17:54:53.569Z","comments":true,"path":"2019/04/17/面试总结和知识梳理/","link":"","permalink":"http://yoursite.com/2019/04/17/面试总结和知识梳理/","excerpt":"","text":"1 前言整理下自己准备面试以及面试过程中所遇到的一些问题，包括自己曾经的项目内容的简单整理，以及一些基本的面试点 2 项目介绍简单介绍 采用技术/担任职责 主要问题&amp;解决方法 闪光点 2.1 上创： 小组组长 主要负责flask项目中的后端算法，参与前后端整合 web应用，协同过滤算法 书籍推荐系统，建立在学校推出的图书评分系统上 应用主要内容分为2块： 1是根据用户推荐书籍 老用户 基于用户推荐：计算用户与其他用户之间的关系度（欧几里得/皮尔逊距离），得到相似度高的用户，并遍历字典，计算不同用户相似度和偏好书籍的权值，得到推荐结果 基于书籍推荐：将评分字典倒置，计算某本书的相似书籍的矩阵，然后相似的计算书籍以及最相似书籍的字典，最后遍历计算不同书籍相似度和评分的权值 新用户： 根据提供的学院，教师/学生，年级等信息进行加权推荐 2是对过往2年的图书借阅记录进行统计 得到过往两年的图书馆真实节约数据，数据预处理：清洗脏数据 数据可视化，用dashboard展现出来 结构：框架：flask前端：输入用户id-submit-通过request.form进入后台-后台算法得出结果-返回后端：python协同过滤算法 遇到的问题： 推荐速度慢 原因：每次执行算法都需要遍历整个借阅记录，每个遍历还需要计算一次距离；计算量大 解决方法：在计算一次后，将字典存储再来，在之后的推荐时直接调用，时间大幅减少 2.2 大创：alexnet分类图像 个人创新项目 python tensroflow 实现优化后的cnn图像分类模型，并调用pytorch预训练的模型，分类1000类不同风格的图像，1w+测试图像超过75准确率。 改进的cnn网络（归一化层，使得图像能有更大尺寸和分辨率的输入 层数更多，分类更准确） 2.3 毕设 也是导师的实验室项目，大二暑假开始做 深度生成对抗网络（dcgan）实现图像修复模型，可以对不同损失面积，不同类型损失区域（中央一半马赛克低像素随机缺失）的图像进行复原， tensorflow+opencv+openface+gpu， 采用技术： 用cnn实现gan模型，包含d和g，g伪造图像d判断真假，博弈训练（d输入真和假，输出0-1；g输出伪造图像并作为输入迭代生成新伪造图像；）修复阶段让trained g迭代一定次数，最后图像和原图像叠加，得到修复后的图像 3个损失函数：训练阶段1个和修复阶段2个（知觉+环境） 梯度下降 4个不同类型的数据集，超过20w张图像 人脸 建筑 综合 3个测试指标提高容错性：峰值信噪比psnr 结构相似性ssim 均方根误差rmse 提高单指标容错性，测试结果比传统的图像修复技术都好 亮点： 优化：直接将原图像和伪造图像叠加不自然；柏松融合 利用插值构建融合部分的像素更加平滑 openface库：预处理阶段，图像中的人脸位置不均，大小不一，openface了一识别人脸并裁减成模型需要的输入 主要问题：训练不平衡：d损失率远大于g，所以给d加了第二个环境损失函数（未受损区域的像素差异），并让两个损失函数加权求和，提高d的训练程度 2.4 中科院自动化所： 人脸检测优化： 在行人检测这种，人脸尺寸小分辨率低的场景下，使用gan进行人脸的超分辨率重建，让人脸检测更加准确 g：生成伪造人脸。d：判断伪造的图像是否真实并且高分辨率 优点：多损失函数加权，相比传统gan更加高效 3损失函数：伪造（接近人脸）；对抗（交叉墒，判断高分辨率）；分辨（分辨人脸） gan人脸生成，并让生成的人脸通过google人脸识别api facenet cnn实现gan adam优化器调整学习旅 gpu加速 2.5 饿了么： arima和lstm模型预测集群作业的数据 arima纯数学模型，对有周期性的序列拟合更好， lstm更适合周期性不强的时间序列问题，并且具有多变量的输入维度（给的原始数据多维，但是一开始并不知道它们之间的相关性），拟合度超过85，准确率超过80 预测未来一周的作业数量 hdfs资源占用情况和作业严重级别， 最后模型部署到公司的日志监控系统上 闪光点：单独写脚本选择出了针对以往数据的最优的arima参数/lstm多维输入 2.6 长虹 对14种不同的票据分类 两个模型 票据量小传统的svm准确率高，量大用cnn（lenet）先做训练，然后分类 难点：预处理和特征提取：黑白文字，且票据的扫描件位置大小层次不齐；cnn能识别图像，但是对于文字识别较难， 优化：opencv库的函数让图像翻转，同样opencv做了数据增强，gan超分辨率，裁减。增加了模型的层数，扩大归一化尺寸； 2.7 数学建模 主要内容是拟合atm交易的数据，采用平均联动聚类以后用核拟合找出特征值，真实数据数据清洗最重要，脏数据的删除，空数据的删除和补充 2.8 智能交通实验室 主要工作是前端构建，并写了一个api连接后端，后端用node采用sklearn（机器学习库），实现了svm，对交通流量数据进行分类 ajax在交通流量实时更新的情况下可以动态更新分类结果 3. 操作系统 3.1 进程和线程的区别是什么？ 进程：分配资源的最小单元 线程：程序执行的最小单元 一个进程可以包含多个线程；进程启动的时候cpu需要给他分配资源，对系统压力比进程大，你可以把线程看成是轻量级的进程。 区别： 进程：有独立数据段，需要分配独立空间（资源大安全高）； 通信机制复杂 线程：共享数据段，不需要分配独立空间（资源小安全低）； 通信机制方便 选取原则： 进程：多机（cpu效率低），稳定安全 线程：频繁的创建和销毁；大量计算；耗时；多核（cpu效率高）；并行操作 3.2 进程间通信的方式有什么？线程间通信的方式有什么？ 进程：socket，管道，信号，消息，共享内存等多种方式 线程：共享变量，管道 3.3 什么是缓存？有哪些缓存的更新算法？ 存储信息避免重复加载； 强缓存：Cache：高速交换存储器；expires 协商缓存：last-modified和if-modified-since：如果缓存过期用 更新算法：Lfu,lru,fifo: lru:least recent update: 最近不访问或者访问少的今后也不会访问（linklist+hashmap实现） 3.4 当你输入域名访问一个网站的时候，背后的过程是什么？ DNS域名解析-TCP三次握手-nginx反向代理进行负载均衡（前后端分离） 3.5 多线程中有哪些锁 偏向锁 加锁和解锁不需要额外的消耗，如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块场景。 轻量级锁：竞争的线程不会阻塞，提高了程序的响应速度。如果始终得不到锁竞争的线程使用自旋会消耗CPU。追求响应时间。同步块执行速度非常快。 重要级锁：线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。追求吞吐量。同步块执行速度较长。 3.6 线程的状态： 初始new 运行runnable-分为就绪ready（调用线程的start()方法，此线程进入就绪状态，sleep（）结束）和运行中running 阻塞blocked-阻塞于锁 等待waiting 超时等待timeed_waiting-可以在指定时间后自行返回 终止 3.7 创建线程两种方式的区别： 1) 继承Thread类，并且覆盖Thread类的run()方法。这种方法的优点是Thread子类对象就是线程对象，具有Thread类的方法，且具有线程体，但是不适应多继承 2) 实现Runnable接口：如果一个类已经继承了一个类还必须要以线程方式运行，就需要实现Runnable接口。实现Runnable接口的类的对象本身并不是线程对象，只是作为一个创建线程对象的目标对象使用。 3.8 聊天都是新建线程，会影响内存，怎么处理 1）开源(增加内存分配) 2）节流(内存优化): 3.9 线程之间共享数据的方式 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。 将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方式也分配给外部类 3.10 进程通信（分别解释），ping工作原理，中断，线程共享父线程的什么， Ping:命令行指令，一般用于检测网络通与不通 ，也叫时延，其值越大，速度越慢 中断是一种特殊的信号，由硬件设备向CPU发送（如敲击键盘）。当CPU接收到中断信号后，就会马上通知操作系统此信号的到来，然后由操作系统负责处理这些新到来的数据。 4 网络协议： 4.1 计算机网络分为哪几层？ 计算机网络如果是OSI模型的话，分为七层： 物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS 数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM, IEEE 802.5/802.2 网络层：IP，IPX，AppleTalk DDP 传输层：TCP，UDP，SPX 会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP 表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML 应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP TCP／IP协议簇模型的话，分为四层： 数据链路层：ARP,RARP 网络层： IP,ICMP,IGMP 传输层：TCP ,UDP,UGP 应用层：Telnet,FTP,HTTP，SMTP,SNMP. 4.2 TCP和UDP有什么区别？什么场景使用TCP，什么场景什么UDP？哪些应用层协议使用了TCP，哪些使用了UDP？ TCP是可靠传输的：用在发送消息的场景（保证用户数据不丢失） UDP是不可靠传输的：传输快：用在聊天室直播等场景（迅速，即使少量丢包不影响） 4.3 窗口滑动协议？ tcp中，两端都维护着窗口： 发送端窗口：由接受端窗口给出的剩余长度来定义 接收端窗口：实现流量控制 4.4 TCP连接需要几次握手？几次挥手？ 3次握手： 两个序号和三个标志位： （1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 1在第一次消息发送中，客户端把自己的初始序号发送给服务端； 2服务端收到，发送一个应答，也包含自身数据的初始序列号 3当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。 * 4次挥手： * 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 * 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 * 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 * 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 4.5 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 4.6 Socket： 客户端和服务端需要采用socket连接时，需要建立socket连接|（应用层与传输层），应用层通过socket向网络发送请求建立tcp/udp连接 4.7 一个简单的server： `4.7 IO NIO AIO：` * Socket在读取消息的时候是阻塞的，NIO是非阻塞，AIO是异步非阻塞， 4.8 你用过什么linux命令？ Ls cd pwd cp rm whereis gedit 4.9 POST和GET的区别： Post是向服务器传送出数据，get是从服务器获取数据 Get通过url传递，post通过request body 4.10 http和tcp： http： tcp是传输层协议，定义的是数据传输和连接方式的规范； http是应用层协议，定义的是传输数据的内容的规范；HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP； TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。 4.11 https: 在http（明文传输）的基础上加入了SSL层进行加密传输 4.12 http2: 所有数据采用二进制编码；一个tcp存在多条流；header压缩； 4.13 ARQ协议： 超时重重传机制：通过确认和超时机制保证数据的正确送达 停止等待arq: 连续arq： 4.14 拥塞处理 慢开始（拥塞处理窗口）-拥塞避免算法-快速重传 4.15 http常见状态码： 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 5 数据结构 5.1 表： 顺序表：删除/插入节点需要移位 链表：删除/插入节点即可，无需移位 5.2 栈 队列 栈：插入/删除都在栈头执行 队列：删除在队头，插入在队尾 单链队列： 循环队列： 5.3 查找算法： 顺序搜索： 二分搜索： 指数搜索：index=1-2-4-8-16-32-… 5.4 二叉树 满：full 完全：其它层都满，除了最后一层，如果最后一层不满，节点必须集中在左边 遍历：先序VLR 中序LVR 后序LRV 平衡：对任意节点，左比根小，右比根大： Avl：任一节点的孩子节点高度差最大为1；红黑：非黑即白；Root是黑色；红色的儿子必须是黑色 5.5 堆 最大堆：每个节点值比它的子节点都大，且是完全二叉树 5.6 排序 堆排：while（heap.length） {交换最后一个元素和堆顶元素，删除最后一个元素，然后调整为正确堆} 冒泡：把当前元素和下一个元素比较，当前元素大就交换位置 插排：i++ 以此将当前元素和在它之前的序列中排到正确位置 选择排序：遍历一遍找到最小的数，放到第一位，递归 快排：随机选pivot，左边的数比它大，右边的比它小，对左边的和右边的递归 归并排序：从中拆分成两组，分别排序，递归 最后合并 5.7 字典 哈希表：key-value存储结构； 地址冲突解决： 线性探查（直接往后找空位） 平方探查（往后找空位按照1-2-4-8来找） 链地址（同义词组成单链表） 再哈希（） 5.8 图 表示方法：邻接表，邻接矩阵 最小生成树：原图的连通子图，weight最小 计算方法： prim（从第一个点开始加点，每次找权重最小的边连起来的点） Kruscal（确定所有点，链接权重最小的边） 最短路径：从点u到其他所有点的最短路径 计算方法： dijkstra（给两个集合A={u}，B{其他点}， 从B中找到A的最短路径，加入A） DFS（顶点开始，递归访问相邻点，若有点被访问，则回溯到另一个未被访问的顶点） * BFS（顶点开始，依此访问所有相邻点） 5.9 hashmap与hashtable与hashset的区别 6 算法 6.1 进制转换： dec-bin：整数：除2取余；小数：乘2取整 bin-dec： 6.2 左移 &lt;&lt;：10 在二进制中表示为 1010 ，左移一位后变成 10100 6.3 算数右移：10 在二进制中表示为 1010 ，右移一位后变成 101 6.4 动态规划： 将问题拆分成子问题，得到子解就得到了大解（斐波那契数列) 7 git： checkout：定位到某分支 branch：创建新分支 merge：合并 恢复先前的提交：让head后移一位， commit：当当前的改动提交到本地的版本库 reset和rebase：reset不修改commit；rebase会修改commit pull和fetch：pull会更新本地代码库；fetch是取回远端更新，不会对本地执行merge 8 前端： 8.1 js基本类型： null undefined Boolean number string symbol(es6新加入) object 8.2 类型转换 String(234)=’234’ 对象转基本类型：tostring，（先valueof） 字符串转number: var newNumber = parseInt(str, radix) #radix为基数 0对应基数10 8.3 ==和===： ===：严格相等，会比较类型和值 ==：先类型转化再比较值 8.4 new： 新生成一个对象-链接到原型-绑定this-返回新对象 8.5 this： 只在函数内部使用，自动生成的一个对象，绑定函数 8.6 执行上下文： 当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链: 包含自身变量对象和上级变量对象的列表 this 8.7 闭包： 函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包 8.8 深浅拷贝 直接赋值进行拷贝：两者的值会是同一个引用 浅拷贝：b={…a} 深拷贝：通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 8.9 commonjs： node规范：引入了模块机制：require export 8.10 另一种amd：异步定义 8.11 防抖： 防止二次点击操作：防止函数多次调用（例如用户多次滑动页面）：通过限制需要经过的时间，直到再次调用函数，将多次执行-&gt;最后一次执行 8.12 节流：也可防抖，在固定时间内只能调用一次，多次执行-&gt;每隔一段时间执行 8.13 继承 es5提出，在父对象的原型链上定义属性 class 8.14 call apply bind的区别： call，apply：改变this的指向，让新的对象可以执行该函数； bind最后会返回一个函数 8.15 promise： 初始态pending：通过resolve和reject改变 8.16 generator 异步编程 函数名前加*，可以返回next进行代码暂停 8.17 map flatmap reduce map：Map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后append到新的数组中 flatmap：降纬 reduce：作用是数组中的值组合起来，最终得到一个值 8.18 async await async函数返回promise 异步调用 8.19 proxy： 自定义对象中的操作，实现一个数据绑定和监听 8.20 为什么 0.1 + 0.2 != 0.3 js采用ieee 64位版本，0．1和0.2都是无限循环的二进制，末尾会进位，不是标准的3.00000 8.21 var let const的区别： 作用域不同 8.22 正则表达式 9 浏览器 9.1 事件机制: 事件触发3阶段： 事件代理：子节点动态生成，应注册在父节点上（节省空间） 9.2 cookie session的区别： cookie存储sessionid 9.3 浏览器兼容性： css兼容：定制自己的reset.css 交互兼容性： 9.4 js组成： ecmascript（定义脚本语言的属性、方法和对象）+dom（把整个页面规划成由节点层级构成的文档）+bom（处理浏览器宽口和框架） 9.5 ajax优缺点： 优：减轻服务器的负担，按需取数据，最大程度减少冗余请求，局部刷新。 缺：浏览器之间有差异，对流媒体和移动设备支持不够好 9.6 浏览器内核 渲染引擎：负责取得网页的内容、整理讯息，以及计算网页的显示方式 js引擎：析和执行js来实现网页的动态效 9.7 事件委托 9.8 window的onload事件和domcontentloaded谁先谁后？ 9.9 跨域问题： 协议，域名或端口有一个不同就是跨域，ajax请求会失败 解决：jsonp：利用script标签（没有跨域限制的漏洞）指向地址并提供回调函数来接收（只限于get） cors：该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 document.domain：该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 postmessage：这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域 9.10 restful：api风格，用URL定位资源，用HTTP描述操作 9.11 事件循环：浏览器：同步执行代码-遇到settimeout，把该事件放到事件队列（遇到微任务放到微任务空间）继续执行直到同步代码执行结束；之后执行微任务空间，然后执行事件队列中的事件，反复循环node：执行顺序不一定 9.12 存储：* cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 10 性能 10.1 预加载： 有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 10.2 预渲染： 10.3 优化渲染过程： 懒执行（某些逻辑延迟到使用时再计算） 懒加载（不关键的资源延后加载） 10.4 图片优化：减小像素点+减小每个像素点的颜色+加载优化 文件优化：css文件放在head中，script标签放在body底部（js会阻塞渲染） 11 安全 11.1 xss： 跨网站指令码：这类攻击包含html以及恶意脚本语言，修改html节点或执行js 防御：白名单（csp内容安全层）/黑名单过滤/转义输出 11.2 csrf： 跨站请求伪造：挟持用户在当前登陆设备上攻击网站 在评论（get接口）中加入恶意代码 防御：禁止修改get 12 框架 12.1 mvvm： model+view+viewmodel model：后台数据模型，业务逻辑 view：界面，ui组件 viewmodel：监听模型数据的改变和控制试图 model=&gt;view：将后端数据转换为页面，实现方式：数据绑定 view=&gt;model：将页面转换为后台数据，实现方式：dom事件监听 12.2 路由：监听URL变化，然后匹配路由规则： 路由方式：hash模式：路由#后面加hash值 history模式：pushstate（）replacestate（）对浏览器记录进行修改 12.3 virtual dom： 用js模拟dom对象（节点和渲染） 13 vue 13.1 nexttick： 下次dom更新循环结束之后执行延迟回调，用于获得更新后的dom 13.2 生命周期分析 vue实例从创建到销毁的过程：创建前/后-挂载dom前/后-渲染更新前/后-卸载前/后组件在初始化或者数据更新时会出发的钩子函数（类似回调） 第一次加载页面会触发：beforecrate created beforemount mounted 13.3 vue组件参数传递： 父-&gt;子：子通过props方法接受数据 子-&gt;父：emit方法传递参数 14 死锁 系统资源不足/分配不当，进程推进顺序不合理，争夺有限的资源而陷入死锁 synchronized锁和lock的区别： 同步锁：可以放在方法或者代码块前面 需要指定上锁的对象 lock：可以代替同步锁，但是有中断，和定时锁等待 区别： 资源竞争激烈：lock性能比同步好； 反之：同步好 同步锁可以在代码块前面实现 死锁的条件 互斥：一个进程使用一个资源 请求与保持：一个进程请求资源造成阻塞，且对已有的资源不放 不剥夺：进程已获得资源在使用完之前，不能强行剥夺 循环等待：若干进程形成循环等待资源的关系 摈弃死锁的条件： 合理分配资源 避免进程永久占据资源 防止处于等待状态下的进程占用资源 15 设计模式： 15.1 单例模式： 确保一个类只有一个实例，确保了封装行：将构造函数声明为private 15.2 工厂模式： 创建类时不会暴露创建内容，而是通过接口实例化类；更方便构造对象 15.3 装饰器设计模式： 动态给对象添加属性或函数； 15.4 观察者模式： 对象1对多，多个观察者可以监听某个对象；自动更新","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"},{"name":"面试","slug":"基础知识/面试","permalink":"http://yoursite.com/categories/基础知识/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"learningJS","slug":"learningJS","date":"2018-12-13T09:02:36.000Z","updated":"2019-07-31T01:51:16.146Z","comments":true,"path":"2018/12/13/learningJS/","link":"","permalink":"http://yoursite.com/2018/12/13/learningJS/","excerpt":"","text":"output is the best input，以下每一项都可以单独写一篇文章javascript 原型、原型链 闭包 es6的新特性 作用域 全局和局部环境 var let const的区别 ajax xhr this 箭头函数 事件绑定、监听、委托、代理 继承 常用数组方法 defer和async 虚拟dom html html的语义标签 html5新特性 canvas css bootstrap dom 定位元素的几种方法 遍历 浏览器 渲染和绘制 兼容性 布局 模块化 webpack 性能优化","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"javascript","slug":"前端/javascript","permalink":"http://yoursite.com/categories/前端/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"c++tips笔记","slug":"cpp笔记","date":"2018-10-18T08:19:02.000Z","updated":"2019-07-28T17:52:43.745Z","comments":true,"path":"2018/10/18/cpp笔记/","link":"","permalink":"http://yoursite.com/2018/10/18/cpp笔记/","excerpt":"","text":"指针* 是取值运算符，对地址使用可以获得地址中储存的数值。对于指针a，*a表示取a中的值 在 定义 时， 是一个标识符，声明该变量是一个指针，比如说int p; 那p就是一个指向int型的指针 在 调用 时， p是指针p指向的那个变量，比如说之前有int a=5；int p=&amp;a；那么p的值是a的地址，也就是指针p指向a， p则等于a的值，即p=5。 &amp; &amp;在 定义 时则是引用，比如说有定义int a=5；再定义int b=&amp;a；那么这里的b则引用a的值，即b=5，而再给b赋值：b=10，a的值也会变为10。 &amp;在 调用 是地址运算符，对变量使用可以获得该变量的地址, 对于变量b，&amp;b表示取b的地址 example 先定义有int x = 0；int *p = &amp;x； 若定义函数： void fun1（int a）{ a=5；} ，则调用：fun1(x); 之后，x还等于0；因为fun1函数只改变了形参a的值，a只是fun1函数里的局部变量，调用fun1(x)相当于是“a=x;a=5;”，x没变； 若定义函数：void fun2（int &amp;a）{ a=5；} ， 则调用：fun2(x); 之后，x等于5；因为这里的a引用了x的值； 若定义函数：void fun3（int a）{ a=5；} ， 则调用：fun3(p); 之后，x也等于5；因为fun3函数的参数a是一个指针，相当于a=p； a则与 p指向同一地址，改变 a即改变p即x return *this: strcpy和strncpy：strcpy(char *ch1, char *ch2)： 直接将ch2指向的由”\\0”结束的字符串复制到ch1，ch1必须有足够的空间来存储ch2 若ch2长于ch1，还是会复制，但是ch1会溢出* strncpy(char *ch1, char *ch2, n): 将ch2中最多n个字符复制到ch1 如果n&gt;ch1长度，ch1溢出 如果n&lt;ch1长度，且如果 ch2长度&lt;=ch1长度，则ch2前n个字符复制到ch1 ch2长度&gt;ch1长度，出错 建议：将n设置为ch1长度","categories":[{"name":"cpp","slug":"cpp","permalink":"http://yoursite.com/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://yoursite.com/tags/cpp/"}]},{"title":"mac常用指令","slug":"mac常用指令","date":"2018-10-09T18:55:04.000Z","updated":"2019-07-28T17:57:50.521Z","comments":true,"path":"2018/10/10/mac常用指令/","link":"","permalink":"http://yoursite.com/2018/10/10/mac常用指令/","excerpt":"","text":"ps: * 指令名称 指令 实例 参考：https://www.jianshu.com/p/8803bf591956 基本指令目录操作 创建目录 mkdir mkdir dirname 删除目录 rmdir rmdir dirname 移动或重命名一个目录 mvdir mvdir dir1 dir2 改变当前目录 rmdir rmdir dirname 显示当前目录的路径名 pwd pwd 显示当前目录的内容 ls ls -la 文件操作 显示文件内容或连接文件 cat cat filename 显示非文本文件的内容 od od -c filename 复制文件或目录 cp cp file1 file2 删除文件或目录 rm rm filename 改变文件名或所在目录 mv mv file1 file2 使用匹配表达式查找文件 find find . -name &quot;*.c&quot; -print 显示文件类型 file file filename 选择操作 显示文件的最初几行 head head -20 filename 显示文件的最后几行 tail tail -15 filename 显示文件每行中的某些域 cut cut -f1,7 -d: /etc/passwd 从标准输入中删除若干列 colrm colrm 8 20 file2 排序或归并文件 sort sort -d -f -u file1 去掉文件中的重复行 uniq uniq file1 file2 显示两有序文件的公共和非公共行 comm comm file1 file2 统计文件的字符数、词数和行数 wc wc filename 给文件加上行号 nl nl file1 &gt;file2 进程操作 显示进程当前状态 ps ps u 终止进程 kill kill -9 30142 时间操作 显示系统的当前日期和时间 diff diff file1 file2 显示⽇日历 cal cal 8 1996 统计程序的执⾏行行时间 time time a.out 网络与通信操作 远程登录 telnet telnet hpc.sp.net.edu.cn 远程登录 rlogin rlogin hostname -l username 在远程主机执⾏行行指定命令 rsh rsh f01n03 date 在本地主机与远程主机之间传输⽂文件 ftp ftp[ftp.sp.net.edu.cn] 在本地主机与远程主机之间复制⽂文件 rcp rcp[ftp.sp.net.edu.cn] 给⼀一个⽹网络主机发送 回应请求 ping ping hpc.sp.net.edu.cn 阅读和发送电⼦子邮件 mail mail 允许或拒绝接收报⽂文 mesg mesg n core shell 指令 列列出最近执⾏行行过的⼏条命令及编号 history history 重复执⾏行行最近执⾏过的某条命令 r r-2 给某个命令定义别名 alias alias del=rm -i 取消对某个别名的定义 diff diff file1 file2 比较并显示两个文件的差异 unalias unalias del 其它命令 显示操作系统的有关信息 uname uname -a 清除屏幕或窗⼝口内容 clear clear 显示当前所有设置过的环境变量量 env env 列列出当前登录的所有⽤用户 who who 显示当前正进⾏行行操作的⽤用户名 whoami whoami 显示终端或伪终端的名称 tty tty 显示或重置控制键定义 stty stty -a 查询磁盘使⽤用情况 du du -k subdirdf 显示⽂文件系统的总空间和可⽤用空间 /tmp 显示当前系统活动的总信息 w 在本地主机与远程主机之间复制⽂文件 rcp rcp[ftp.sp.net.edu.cn] 给⼀一个⽹网络主机发送 回应请求 ping sudo命令 临时使⽤用root权限来编辑/etc/shadow密码⽂文件 sudo gedit /etc/shadow 注意$和#的变化，#表示你在最⾼高权限root⾥里里⾯面","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"hexo搭建blog常用命令","slug":"hexo搭建blog常用命令","date":"2018-10-09T18:29:32.000Z","updated":"2019-07-28T17:55:28.956Z","comments":true,"path":"2018/10/10/hexo搭建blog常用命令/","link":"","permalink":"http://yoursite.com/2018/10/10/hexo搭建blog常用命令/","excerpt":"","text":"常规搭建常规指令hexo new &quot;blogname&quot; #新建博客 hexo g #生成 hexo s #启动服务器预览 hexo d #部署 hexo clean #清除缓存 更换设备搭建参考：https://www.zhihu.com/question/21193762/answer/103097754 打开git bash，在用户主目录下运行： ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把其中的邮件地址换成自己的邮件地址，然后一路回车 最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。 下载Node.js，并安装. 打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo 下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。 1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文 件，像站点配置_config.yml，theme文件夹里面的主题， 以及source里面自己写的博客文件，这些肯定要拷贝的。除 此之外，还有 三个文件需要有，就是scaffolds文件夹（文章的模板）、 package.json（说明使用哪些包）和.gitignore（限定在 提交的时候哪些文件可以忽略）。其实，这三个文件不是我们 修改的，所以即使丢失了，也没有关系，我们可以建立一个新 的文件夹，然后在里面执行hexo init，就会生成这三个文 件，我们只需要将它们拷贝过来使用即可。总结： _config.yml，theme/，source/，scaffolds/， package.json，.gitignore，是需要拷贝的。 &nbsp; （2）再讨论下哪些文件是不必拷贝的，或者说可以删除的： 首先是.git文件，无论是在站点根目录下，还是主题目录下 的.git文件，都可以删掉。然后是文件夹 node_modules（在用npm install会重新生成）， public（这个在用hexo g时会重新生成），.deploy_git 文件夹（在使用hexo d时也会重新生成），db.json文件。 其实上面这些文件也就是.gitignore文件里面记载的可以忽 略的内容。总结：.git/，node_modules/， public/，.deploy_git/，db.json文件需要删除。 在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了： （1）为了使用hexo d来部署到git上，需要安装 npm install hexo-deployer-git --save （2）为了建立RSS订阅，需要安装 npm install hexo-generator-feed --save （3）为了建立站点地图，需要安装 npm install hexo-generator-sitemap --save 插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"},{"name":"hexo","slug":"blog/hexo","permalink":"http://yoursite.com/categories/blog/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"用CNN实现深度生成对抗网络GAN","slug":"用CNN实现深度生成对抗网络GAN","date":"2018-09-10T14:32:01.000Z","updated":"2019-09-19T09:01:00.912Z","comments":true,"path":"2018/09/10/用CNN实现深度生成对抗网络GAN/","link":"","permalink":"http://yoursite.com/2018/09/10/用CNN实现深度生成对抗网络GAN/","excerpt":"","text":"GAN生成对抗网络（Generative Adversarial Network，GAN）是近几年很热门的一种深度学习神经网络模型，是目前在复杂分布上进行无监督学习最前沿的模型之一，这个概念由Ian Goodfellow和Yoshua Bengio等人在2014年提出，GAN的核心思想源自博弈论，它通过构造生成器（Generator）和判别器（Discriminator）在训练过程中互相博弈学习，最终得到理想的结果。其中生成器的目的在于生成虚假的样本分布，判别器的目的在于判别出输入的样本是否真实。由于GAN模型“博弈”的这一特点，它已经开始被应用到语音和语言处理、电脑病毒监测、棋类比赛程序等问题的研究当中。另外，GAN最常用的领域还是图像处理和计算机视觉，进行图像生成，构成各种逼真的室内外场景。 GAN的基本模型 CNN实现GANGAN提出的是一种对抗模型的思想，而要实现它，目前流行的是使用感知器或者多层神经网络。而用CNN来实现，可以大大解决GAN难以训练和不够稳定的问题，并且可以提高生成样本的质量、收敛速度，以及拓展维度。CNN实现的改进： 去掉了G和D中的池化层（pooling layer），并用微步幅卷积替代，能够分别使得G和D的下采样和上采样效率更高。 在G和D中使用批量规范化（Batch Normalization），通过将输入的每个样本单元标准化为0均值和单位方差来稳定学习，这有助于处理初始化不良导致的训练问题，也有助于梯度流向更深的网络层。 去掉最后一层卷积层后面的全连接层（fully layer），将生成器和判别器直接相连，能够有效提高模型收敛速率。 生成器中除了输出层采用Tanh激活函数，其余所有层都采用ReLU激活函数。 判别器中所有层都采用Leaky ReLU激活函数。 模型设计生成器模型生成器的网络由4层卷积层构成 第1层：卷积核大小为5”×” 5，步长2，“same”填充，深度512，输出样本尺寸8”×” 8，生成函数ReLU 第2层：卷积核大小为5”×” 5，步长2，“same”填充，深度256，输出样本尺寸16”×” 16，生成函数ReLU 第3层：卷积核大小为5”×” 5，步长2，“same”填充，深度128，输出样本尺寸32”×” 32，生成函数ReLU 第4层：卷积核大小为5”×” 5，步长2，“same”填充，深度3，输出样本尺寸64”×” 64，生成函数Tanh 判别器模型判别器的4层卷积层具体如下： 第1层：卷积核大小为5”×” 5，步长2，“same”填充，深度64，输出样本尺寸32”×” 32，生成函数Leaky ReLU。 第2层：卷积核大小为5”×” 5，步长2，“same”填充，深度128，输出样本尺寸16”×” 16，生成函数Leaky ReLU。 第3层：卷积核大小为5”×” 5，步长2，“same”填充，深度256，输出样本尺寸8”×” 8，生成函数Leaky ReLU。 第4层：卷积核大小为5”×” 5，步长2，“same”填充，深度512，输出样本尺寸4”×” 4，生成函数Sigmoid。 构建模型 构建生成器模型def generator(self, z): self.z_, self.h0_w, self.h0_b = linear(z, self.gf_dim84*4, &#39;g_h0_lin&#39;, with_w=True) self.h0 = tf.reshape(self.z_, [-1, 4, 4, self.gf_dim * 8])h0 = tf.nn.relu(self.g_bn0(self.h0)) //第1层微步幅卷积层 self.h1, self.h1_w, self.h1_b = conv2d_transpose(h0,[self.batch_size, 8, 8, self.gf_dim*4], name=’g_h1’, with_w=True)h1 = tf.nn.relu(self.g_bn1(self.h1)) //第2层微步幅卷积层 h2, self.h2_w, self.h2_b = conv2d_transpose(h1, [self.batch_size, 16, 16, self.gf_dim*2], name=’g_h2’, with_w=True)h2 = tf.nn.relu(self.g_bn2(h2)) //第3层微步幅卷积层 h3, self.h3_w, self.h3_b = conv2d_transpose(h2, [self.batch_size, 32, 32, self.gf_dim*1], name=’g_h3’, with_w=True) h3 = tf.nn.relu(self.g_bn3(h3)) //第4层微步幅卷积层，4层微步幅卷积后，矩阵维度变为（64, 64, 3） h4, self.h4_w, self.h4_b = conv2d_transpose(h3, [self.batch_size, 64, 64, 3], name=’g_h4’, with_w=True) return tf.nn.tanh(h4) 构建判别器模型def discriminator(self, image, reuse=False)://第1层卷积h0 = lrelu(conv2d(image, self.df_dim, name=’d_h0_conv’)) //第2层卷积h1 = lrelu(self.d_bn1(conv2d(h0, self.df_dim*2, name=’d_h1_conv’))) //第3层卷积h2 = lrelu(self.d_bn2(conv2d(h1, self.df_dim*4, name=’d_h2_conv’))) //第4层卷积 h3 = lrelu(self.d_bn3(conv2d(h2, self.df_dim*8, name=’d_h3_conv’))) h4 = linear(tf.reshape(h3, [-1, 8192]), 1, ‘d_h3_lin’) return tf.nn.sigmoid(h4), h4 构建优化器//判别器优化器，最小化损失函数d_optim = tf.train.AdamOptimizer(config.learning_rate, beta1=config.beta1) \\ .minimize(self.d_loss, var_list=self.d_vars) //判别器优化器，最小化损失函数g_optim = tf.train.AdamOptimizer(config.learning_rate, beta1=config.beta1) \\ .minimize(self.g_loss, var_list=self.g_vars)","categories":[{"name":"machine learning","slug":"machine-learning","permalink":"http://yoursite.com/categories/machine-learning/"},{"name":"gan","slug":"machine-learning/gan","permalink":"http://yoursite.com/categories/machine-learning/gan/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://yoursite.com/tags/machine-learning/"}]},{"title":"目前的learning plan","slug":"基础知识","date":"2018-07-15T13:23:22.000Z","updated":"2019-07-29T05:03:56.987Z","comments":true,"path":"2018/07/15/基础知识/","link":"","permalink":"http://yoursite.com/2018/07/15/基础知识/","excerpt":"","text":"必须掌握的基础知识，主要分为数据结构、算法、操作系统、数据库、前端等。不定期更新数据结构 表 堆栈 队列 数组 树 完全二叉树：除了最后一层以外，其余层必满；最后一层可以是满，如果不满，则节点必须集中在左边 最大堆：1.必须是完全二叉树 2.节点的值必须大于左右子树的值 二叉搜索树：左孩子比父母小，右孩子比父母大。 avl树：一种平衡二叉搜索树，并且任意节点的孩子节点高度差最大为1. 平衡因子：某节点的平衡因子是该节点左子树的高度减右子树的高度（avl只能是0，1，-1 红黑树： 节点是红色或黑色。 根是黑色。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 图 算法 排序 查找 hash 算法思想-递归 算法思想-贪心 算法思想-回溯 算法思想-分支 算法思想-动态规划 数据库 索引 视图 触发器 范式 锁 存储过程 事物 B+树 E-R图 3.10补充-mysql、mongodb 操作系统 并发性（concurrence） 在一个系统（或者一段时间）中，有多个同时执行的程序进行计算，并且它们之间存在潜在的交互。优点：资源利用率高、程序设计更简化、程序响应更快、系统性能更高；缺点：存在并发性的系统会有不同的程序运行路径，所以系统的处理结果会有不确定性。 进程（process）、线程（thread） 一个应用程序包含一个或多个相互协作的进程。 进程：一块包含一些资源的内存区域，组成为一段一定大小（4GB）的线性内存空间。 线程：进程中包含的一个或多个执行单元，无内存空间，只有指针、栈、寄存器、数据区。 一个程序至少有一个进程，一个进程至少有一个线程。进程和线程都是系统（程序）的执行单元。 差别：进程具有独立的地址空间（供它包含的线程访问），线程没有，所以如果一个进程崩溃，在保护模式下不会对其他进程产生影响；而一个线程死掉就等于整个进程死掉（多进程程序比多线程程序健壮），但是进程切换时耗费的资源多，效率差。 异步、同步处理、阻塞和非阻塞 同步调用：调用之后就能得到结果 异步调用：调用之后需要其他方法（状态、通知、回调函数）来得到结果。 同步线程：两个线程的步调要一致，如果二者运行速度不一样，则快的等慢的（快的阻塞一下等慢的）。 异步线程：两个线程的步调不一致，各自独立运行。 同步I/O：不发送成功或失败状态，一直等待。 异步I/O：输入/输出时立即返回成功或失败的状态。 阻塞：进程或线程停止。 阻塞I/O：资源不可用时（输入/输出未完成，I/O一直阻塞，直到完成。 非阻塞I/O：资源不可用超过一定时间后，直接结束本次I/O。 调度、死锁 死锁：两个或多个执行单元之间相互等待对方结束而引起阻塞的情况。 例：T1有R1的访问权、T2有R2的访问权。 T1想访问R2，同时T2想访问R1，此时T1和T2都要等待对方给出权限，形成死锁。 存储器管理 文件管理 IO阻塞 用户态、核心态 nodejs express框架、es6、es7 前端框架 react、vuejs、angularjs IOS开发","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"plan","slug":"plan","permalink":"http://yoursite.com/tags/plan/"}]},{"title":"《深入浅出NodeJS》读书笔记","slug":"《深入浅出NodeJS》读书笔记","date":"2018-07-15T12:20:07.000Z","updated":"2019-08-19T03:00:29.188Z","comments":true,"path":"2018/07/15/《深入浅出NodeJS》读书笔记/","link":"","permalink":"http://yoursite.com/2018/07/15/《深入浅出NodeJS》读书笔记/","excerpt":"","text":"第一章 Node Node：“一个强制不共享任何资源的单线程、单进程系统，通过协议构建不同的node来形成一个大型的网路应用，每一个node为一个节点”，这是书中给的解释原文 非阻塞I/O 书中多次提到的概念，我理解的非阻塞就是线程或进程的停止， 特点 1.异步 2.事件（随意绑定事件），时间绑定轻量级、松耦合 3.回调函数 Ajax请求：快速动态刷新网页，不刷新，直接更新参数 读完第一章以后，觉得云里雾里，这本书对于没有JS基础的人来说有点头疼。不过能肯定的是nodejs是一门异步I/O的语言，和python等编程习惯不一样，需要适应。 至此，我决定先啃《js高级程序设计第三版》这本书，对js有一定的了解以后再来学习nodejs。 第二章C/S模式：客户/服务器模式，例如微信等B/S模式：浏览器/服务器模式，例如各种web应用 CommonJS规范： 相比于python的import，JAVA的类文件等，js是没有模块引入机制的，只能通过&lt;script&gt;标签这种杂乱的方式引入代码。在nodejs未出现之前，js只能用于前端，只有Rhino等后端javascript运行环境来作为小工具。node这么多年发展以来，已经形成了一套响应的规范，也就是CommonJS规范。 1.模块引用：var math = require(&#39;math&#39;); 2.模块定义：export.add = function(){...;return sum}; export.increment = function(val){}; 3.模块标识： node模块实现： node引入模块需要3个步骤：路径分析、文件定位、编译执行，其中系统自带的模块为核心模块，直接随node启动时加载进内存，加载速度快；用户自定义的模块称为文件模块，在运行时动态加载，慢。 1.路径分析：require(&#39;标识符&#39;)；//分析标识符，标识符主要分为： *核心模块，如http、fs、path等。 *.或..等相对路径文件模块 *以/开始的绝对路径文件模块 *非路径形式的文件模块，如自定义的connect模块 （自定义模块非核心模块和路径形式的模块，分析速度最慢） 2.文件定位： *扩展名分析：模块文件可以不带扩展名，自动按.js、.json、.node顺序补全。 *目标分析和包： 3.模块编译 *核心模块一般为C/C++或javascript编译，所有的都转换为C/C++然后编译 4.内建模块：全由C/C++编译的模块，使用： process.binding(&#39;标识符&#39;) 来进行导出 包与NPM： &quot;package.json&quot;：包含包的所有信息（版本、名称、作者等） NPM已经是一个包共享平台，实现第三方模块的发布、安装和依赖。 前后端共用模块： 前端规范：AMD规范、CMD规范 1.AMD规范定义的模块需要用define： define(function(){...}) 2.CMD规范申明时要指定所有的依赖 第三章tips：js异步回调函数复习Promise() resolve()： pending-&gt;fulfilled pending-&gt;rejected reject()","categories":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/categories/node-js/"}],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]}]}