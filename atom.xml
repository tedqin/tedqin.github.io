<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一条想成为大佬的咸鱼</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-25T16:49:38.833Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ted Qin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统</title>
    <link href="http://yoursite.com/2018/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/10/25/分布式系统/</id>
    <published>2018-10-25T16:48:39.000Z</published>
    <updated>2018-10-25T16:49:38.833Z</updated>
    
    <content type="html"><![CDATA[<p>新坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新坑&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c++tips笔记</title>
    <link href="http://yoursite.com/2018/10/18/c-tips%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/18/c-tips笔记/</id>
    <published>2018-10-18T15:19:02.000Z</published>
    <updated>2018-10-30T16:20:16.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id=""><a href="#" class="headerlink" title="*"></a>*</h3><ul><li><ul><li>是取值运算符，对地址使用可以获得地址中储存的数值。对于指针a，*a表示取a中的值</li></ul></li><li>在 <em>定义</em> 时，<em> 是一个标识符，声明该变量是一个指针，比如说int </em>p; 那p就是一个指向int型的指针</li><li>在 <em>调用</em> 时，<em> p是指针p指向的那个变量，比如说之前有int a=5；int </em> p=&amp;a；那么p的值是a的地址，也就是指针p指向a，<em> p则等于a的值，即</em>p=5。</li></ul><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><ul><li>&amp;在 <em>定义</em> 时则是引用，比如说有定义int a=5；再定义int b=&amp;a；那么这里的b则引用a的值，即b=5，而再给b赋值：b=10，a的值也会变为10。</li><li>&amp;在 <em>调用</em> 是地址运算符，对变量使用可以获得该变量的地址, 对于变量b，&amp;b表示取b的地址</li></ul><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><ul><li>先定义有int x = 0；int *p = &amp;x；</li><li>若定义函数： void fun1（int a）{ a=5；} ，则调用：fun1(x); 之后，x还等于0；因为fun1函数只改变了形参a的值，a只是fun1函数里的局部变量，调用fun1(x)相当于是“a=x;a=5;”，x没变；</li><li>若定义函数：void fun2（int &amp;a）{ a=5；} ， 则调用：fun2(x); 之后，x等于5；因为这里的a引用了x的值；</li><li>若定义函数：void fun3（int <em> a）{ </em> a=5；} ， 则调用：fun3(p); 之后，x也等于5；因为fun3函数的参数a是一个指针，相当于a=p；<em> a则与</em> p指向同一地址，改变<em> a即改变</em>p即x</li><li>return *this:</li><li></li></ul><h2 id="strcpy和strncpy："><a href="#strcpy和strncpy：" class="headerlink" title="strcpy和strncpy："></a>strcpy和strncpy：</h2><p><code>strcpy(char *ch1, char *ch2)</code>：</p><ul><li>直接将ch2指向的由”\0”结束的字符串复制到ch1，ch1必须有足够的空间来存储ch2</li><li>若ch2长于ch1，还是会复制，但是ch1会溢出<br>*</li></ul><p><code>strncpy(char *ch1, char *ch2, n)</code>:</p><ul><li>将ch2中最多n个字符复制到ch1</li><li>如果n&gt;ch1长度，ch1溢出</li><li>如果n&lt;ch1长度，且如果<ul><li>ch2长度&lt;=ch1长度，则ch2前n个字符复制到ch1</li><li>ch2长度&gt;ch1长度，出错</li></ul></li><li>建议：将n设置为ch1长度</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h2&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;*&quot;&gt;&lt;/a&gt;*&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>xcode调试技巧-常用命令和断点</title>
    <link href="http://yoursite.com/2018/10/12/xcode%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E6%96%AD%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/12/xcode调试技巧-常用命令和断点/</id>
    <published>2018-10-11T23:07:51.000Z</published>
    <updated>2018-10-11T23:50:14.674Z</updated>
    
    <content type="html"><![CDATA[<p>新坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新坑&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac常用指令</title>
    <link href="http://yoursite.com/2018/10/10/mac%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/10/mac常用指令/</id>
    <published>2018-10-10T01:55:04.000Z</published>
    <updated>2018-10-16T11:50:18.650Z</updated>
    
    <content type="html"><![CDATA[<p>ps: * 指令名称 <code>指令</code> <code>实例</code></p><p>参考：<a href="https://www.jianshu.com/p/8803bf591956" target="_blank" rel="noopener">https://www.jianshu.com/p/8803bf591956</a></p><h1 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul><li>创建目录 <code>mkdir</code> <code>mkdir dirname</code></li><li>删除目录 <code>rmdir</code> <code>rmdir dirname</code></li><li>移动或重命名一个目录 <code>mvdir</code> <code>mvdir dir1 dir2</code></li><li>改变当前目录 <code>rmdir</code> <code>rmdir dirname</code></li><li>显示当前目录的路径名 <code>pwd</code> <code>pwd</code></li><li>显示当前目录的内容 <code>ls</code> <code>ls -la</code></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li>显示文件内容或连接文件 <code>cat</code> <code>cat filename</code></li><li>显示非文本文件的内容 <code>od</code> <code>od -c filename</code></li><li>复制文件或目录 <code>cp</code> <code>cp file1 file2</code></li><li>删除文件或目录 <code>rm</code> <code>rm filename</code></li><li>改变文件名或所在目录 <code>mv</code> <code>mv file1 file2</code></li><li>使用匹配表达式查找文件 <code>find</code> <code>find . -name &quot;*.c&quot; -print</code></li><li>显示文件类型 <code>file</code> <code>file filename</code></li></ul><h2 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h2><ul><li>显示文件的最初几行 <code>head</code> <code>head -20 filename</code></li><li>显示文件的最后几行 <code>tail</code> <code>tail -15 filename</code></li><li>显示文件每行中的某些域 <code>cut</code> <code>cut -f1,7 -d: /etc/passwd</code></li><li>从标准输入中删除若干列 <code>colrm</code> <code>colrm 8 20 file2</code></li><li>排序或归并文件 <code>sort</code> <code>sort -d -f -u file1</code></li><li>去掉文件中的重复行 <code>uniq</code> <code>uniq file1 file2</code></li><li>显示两有序文件的公共和非公共行 <code>comm</code> <code>comm file1 file2</code></li><li>统计文件的字符数、词数和行数 <code>wc</code> <code>wc filename</code></li><li>给文件加上行号 <code>nl</code> <code>nl file1 &gt;file2</code></li></ul><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><ul><li>显示进程当前状态 <code>ps</code> <code>ps u</code></li><li>终止进程 <code>kill</code> <code>kill -9 30142</code></li></ul><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><ul><li>显示系统的当前日期和时间 <code>diff</code> <code>diff file1 file2</code></li><li>显示⽇日历 <code>cal</code> <code>cal 8 1996</code></li><li>统计程序的执⾏行行时间 <code>time</code> <code>time a.out</code></li></ul><h2 id="网络与通信操作"><a href="#网络与通信操作" class="headerlink" title="网络与通信操作"></a>网络与通信操作</h2><ul><li>远程登录 <code>telnet</code> <code>telnet hpc.sp.net.edu.cn</code></li><li>远程登录 <code>rlogin</code> <code>rlogin hostname -l username</code></li><li>在远程主机执⾏行行指定命令 <code>rsh</code> <code>rsh f01n03 date</code></li><li>在本地主机与远程主机之间传输⽂文件 <code>ftp</code> <code>ftp[ftp.sp.net.edu.cn]</code></li><li>在本地主机与远程主机之间复制⽂文件 <code>rcp</code> <code>rcp[ftp.sp.net.edu.cn]</code></li><li>给⼀一个⽹网络主机发送 回应请求 <code>ping</code> <code>ping hpc.sp.net.edu.cn</code></li><li>阅读和发送电⼦子邮件 <code>mail</code> <code>mail</code></li><li>允许或拒绝接收报⽂文 <code>mesg</code> <code>mesg n</code></li></ul><h2 id="core-shell-指令"><a href="#core-shell-指令" class="headerlink" title="core shell 指令"></a>core shell 指令</h2><ul><li>列列出最近执⾏行行过的⼏条命令及编号 <code>history</code> <code>history</code></li><li>重复执⾏行行最近执⾏过的某条命令 <code>r</code> <code>r-2</code></li><li>给某个命令定义别名 <code>alias</code> <code>alias del=rm -i</code></li><li>取消对某个别名的定义 <code>diff</code> <code>diff file1 file2</code></li><li>比较并显示两个文件的差异 <code>unalias</code> <code>unalias del</code></li></ul><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><ul><li>显示操作系统的有关信息 <code>uname</code> <code>uname -a</code></li><li>清除屏幕或窗⼝口内容 <code>clear</code> <code>clear</code></li><li>显示当前所有设置过的环境变量量 <code>env</code> <code>env</code></li><li>列列出当前登录的所有⽤用户 <code>who</code> <code>who</code></li><li>显示当前正进⾏行行操作的⽤用户名 <code>whoami</code> <code>whoami</code></li><li>显示终端或伪终端的名称 <code>tty</code> <code>tty</code></li><li>显示或重置控制键定义 <code>stty</code> <code>stty -a</code></li><li>查询磁盘使⽤用情况 <code>du</code> <code>du -k subdirdf</code></li><li>显示⽂文件系统的总空间和可⽤用空间 <code>/tmp</code> </li><li>显示当前系统活动的总信息 <code>w</code> </li><li>在本地主机与远程主机之间复制⽂文件 <code>rcp</code> <code>rcp[ftp.sp.net.edu.cn]</code></li><li>给⼀一个⽹网络主机发送 回应请求 <code>ping</code> </li></ul><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><ul><li>临时使⽤用root权限来编辑/etc/shadow密码⽂文件 <code>sudo gedit /etc/shadow</code> </li><li>注意$和#的变化，#表示你在最⾼高权限root⾥里里⾯面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ps: * 指令名称 &lt;code&gt;指令&lt;/code&gt; &lt;code&gt;实例&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.jianshu.com/p/8803bf591956&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http
      
    
    </summary>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建blog常用命令</title>
    <link href="http://yoursite.com/2018/10/10/hexo%E6%90%AD%E5%BB%BAblog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/10/hexo搭建blog常用命令/</id>
    <published>2018-10-10T01:29:32.000Z</published>
    <updated>2018-10-23T11:35:59.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常规搭建"><a href="#常规搭建" class="headerlink" title="常规搭建"></a>常规搭建</h2><h2 id="常规指令"><a href="#常规指令" class="headerlink" title="常规指令"></a>常规指令</h2><h2 id="更换设备搭建"><a href="#更换设备搭建" class="headerlink" title="更换设备搭建"></a>更换设备搭建</h2><p>参考：<a href="https://www.zhihu.com/question/21193762/answer/103097754" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/103097754</a></p><ul><li>打开git bash，在用户主目录下运行：</li></ul><p><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code> </p><p>把其中的邮件地址换成自己的邮件地址，然后一路回车</p><ul><li><p>最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p></li><li><p>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。</p></li><li>下载Node.js，并安装.</li><li>打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo</li><li><p>下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。</p><pre><code>      1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文      件，像站点配置_config.yml，theme文件夹里面的主题，      以及source里面自己写的博客文件，这些肯定要拷贝的。除      此之外，还有      三个文件需要有，就是scaffolds文件夹（文章的模板）、      package.json（说明使用哪些包）和.gitignore（限定在      提交的时候哪些文件可以忽略）。其实，这三个文件不是我们      修改的，所以即使丢失了，也没有关系，我们可以建立一个新      的文件夹，然后在里面执行hexo init，就会生成这三个文      件，我们只需要将它们拷贝过来使用即可。总结：      _config.yml，theme/，source/，scaffolds/，      package.json，.gitignore，是需要拷贝的。</code></pre><p>&nbsp;</p><pre><code>      （2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：      首先是.git文件，无论是在站点根目录下，还是主题目录下      的.git文件，都可以删掉。然后是文件夹      node_modules（在用npm install会重新生成），      public（这个在用hexo g时会重新生成），.deploy_git      文件夹（在使用hexo d时也会重新生成），db.json文件。      其实上面这些文件也就是.gitignore文件里面记载的可以忽      略的内容。总结：.git/，node_modules/，      public/，.deploy_git/，db.json文件需要删除。</code></pre></li><li><p>在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</p></li><li><p>安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：</p><pre><code>  （1）为了使用hexo d来部署到git上，需要安装</code></pre><p>  <code>npm install hexo-deployer-git --save</code></p><pre><code>  （2）为了建立RSS订阅，需要安装</code></pre><p>  <code>npm install hexo-generator-feed --save</code></p><pre><code>  （3）为了建立站点地图，需要安装</code></pre><p>  <code>npm install hexo-generator-sitemap --save</code></p><p>  插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明</p></li><li><p>使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常规搭建&quot;&gt;&lt;a href=&quot;#常规搭建&quot; class=&quot;headerlink&quot; title=&quot;常规搭建&quot;&gt;&lt;/a&gt;常规搭建&lt;/h2&gt;&lt;h2 id=&quot;常规指令&quot;&gt;&lt;a href=&quot;#常规指令&quot; class=&quot;headerlink&quot; title=&quot;常规指令&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迷茫</title>
    <link href="http://yoursite.com/2018/08/11/%E8%BF%B7%E8%8C%AB/"/>
    <id>http://yoursite.com/2018/08/11/迷茫/</id>
    <published>2018-08-11T17:08:22.000Z</published>
    <updated>2018-08-11T10:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>对未来的方向不是很明确，目前暂时的新知识学习计划是JS-NODEJS-IOS</p><p>觉得自己并不擅长后端开发，但是感觉web开发的前景不是很好，移动开发可能是对我最好的一个选择。</p><p>于是决定自己先分别上手一下，nodejs、js和ios简单应用，看看自己更喜欢哪个。</p><p>继续nodejs吧，坚持</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对未来的方向不是很明确，目前暂时的新知识学习计划是JS-NODEJS-IOS&lt;/p&gt;
&lt;p&gt;觉得自己并不擅长后端开发，但是感觉web开发的前景不是很好，移动开发可能是对我最好的一个选择。&lt;/p&gt;
&lt;p&gt;于是决定自己先分别上手一下，nodejs、js和ios简单应用，看看自己
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新坑-IOS开发</title>
    <link href="http://yoursite.com/2018/08/11/%E6%96%B0%E5%9D%91-IOS%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/08/11/新坑-IOS开发/</id>
    <published>2018-08-11T16:51:18.000Z</published>
    <updated>2018-08-11T09:51:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>目前的learning plan</title>
    <link href="http://yoursite.com/2018/07/15/%E7%9B%AE%E5%89%8D%E7%9A%84learning-plan/"/>
    <id>http://yoursite.com/2018/07/15/目前的learning-plan/</id>
    <published>2018-07-15T20:23:22.000Z</published>
    <updated>2018-08-11T10:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构</p><ul><li>表</li><li>堆栈</li><li>队列</li><li>数组</li><li>树</li><li>图</li></ul><p>算法</p><ul><li>排序</li><li>查找</li><li>hash</li><li>算法思想-递归</li><li>算法思想-贪心</li><li>算法思想-回溯</li><li>算法思想-分支</li><li>算法思想-动态规划</li></ul><p>数据库</p><ul><li>索引</li><li>视图</li><li>触发器</li><li>范式</li><li>锁</li><li>存储过程</li><li>事物</li><li>B+树</li><li>E-R图</li><li>3.10补充-mysql、mongodb</li></ul><p>操作系统</p><ul><li><p>并发性（concurrence）</p><p>  在一个系统（或者一段时间）中，有多个同时执行的程序进行计算，并且它们之间存在潜在的交互。优点：资源利用率高、程序设计更简化、程序响应更快、系统性能更高；缺点：存在并发性的系统会有不同的程序运行路径，所以系统的处理结果会有不确定性。</p></li><li><p>进程（process）、线程（thread）</p><p>  一个应用程序包含一个或多个相互协作的进程。</p><pre><code>  进程：一块包含一些资源的内存区域，组成为一段一定大小（4GB）的线性内存空间。  线程：进程中包含的一个或多个执行单元，无内存空间，只有指针、栈、寄存器、数据区。</code></pre><p>  一个程序至少有一个进程，一个进程至少有一个线程。进程和线程都是系统（程序）的执行单元。<br>  差别：进程具有独立的地址空间（供它包含的线程访问），线程没有，所以如果一个进程崩溃，在保护模式下不会对其他进程产生影响；而一个线程死掉就等于整个进程死掉（多进程程序比多线程程序健壮），但是进程切换时耗费的资源多，效率差。</p></li><li><p>异步、同步处理、阻塞和非阻塞</p><pre><code>  同步调用：调用之后就能得到结果  异步调用：调用之后需要其他方法（状态、通知、回调函数）来得到结果。  同步线程：两个线程的步调要一致，如果二者运行速度不一样，则快的等慢的（快的阻塞一下等慢的）。  异步线程：两个线程的步调不一致，各自独立运行。  同步I/O：不发送成功或失败状态，一直等待。  异步I/O：输入/输出时立即返回成功或失败的状态。</code></pre><p>  阻塞：进程或线程停止。</p><pre><code>  阻塞I/O：资源不可用时（输入/输出未完成，I/O一直阻塞，直到完成。  非阻塞I/O：资源不可用超过一定时间后，直接结束本次I/O。</code></pre></li><li><p>调度、死锁</p><p>  死锁：两个或多个执行单元之间相互等待对方结束而引起阻塞的情况。</p><pre><code>  例：T1有R1的访问权、T2有R2的访问权。      T1想访问R2，同时T2想访问R1，此时T1和T2都要等待对方给出权限，形成死锁。</code></pre></li><li>存储器管理</li><li>文件管理</li><li>IO阻塞</li><li>用户态、核心态</li></ul><p>nodejs</p><pre><code>express框架、es6、es7</code></pre><p>前端框架</p><pre><code>react、vuejs、angularjs</code></pre><p>IOS开发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表&lt;/li&gt;
&lt;li&gt;堆栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序&lt;/li&gt;
&lt;li&gt;查找&lt;/li&gt;
&lt;li&gt;hash&lt;
      
    
    </summary>
    
    
      <category term="plan" scheme="http://yoursite.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出NodeJS》读书笔记</title>
    <link href="http://yoursite.com/2018/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/15/《深入浅出NodeJS》读书笔记/</id>
    <published>2018-07-15T19:20:07.000Z</published>
    <updated>2018-08-12T15:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>##第一章 </p><ul><li><p>Node</p><p>  Node：“一个强制不共享任何资源的单线程、单进程系统，通过协议构建不同的node来形成一个大型的网路应用，每一个node为一个节点”，这是书中给的解释原文</p></li><li><p>非阻塞I/O</p><p>  书中多次提到的概念，我理解的非阻塞就是线程或进程的停止，</p></li><li>特点</li><li><pre><code>  1.异步  2.事件（随意绑定事件），时间绑定轻量级、松耦合  3.回调函数    </code></pre></li><li><p>Ajax请求：快速动态刷新网页，不刷新，直接更新参数</p></li></ul><p>读完第一章以后，觉得云里雾里，这本书对于没有JS基础的人来说有点头疼。不过能肯定的是nodejs是一门异步I/O的语言，和python等编程习惯不一样，需要适应。</p><p>至此，我决定先啃《js高级程序设计第三版》这本书，对js有一定的了解以后再来学习nodejs。</p><p>##第二章</p><p>C/S模式：客户/服务器模式，例如微信等<br>B/S模式：浏览器/服务器模式，例如各种web应用</p><ul><li><p>CommonJS规范：</p><p>  相比于python的import，JAVA的类文件等，js是没有模块引入机制的，只能通过&lt;script&gt;标签这种杂乱的方式引入代码。在nodejs未出现之前，js只能用于前端，只有Rhino等后端javascript运行环境来作为小工具。node这么多年发展以来，已经形成了一套响应的规范，也就是CommonJS规范。</p><pre><code>  1.模块引用：var math = require(&#39;math&#39;);  2.模块定义：export.add = function(){...;return sum};             export.increment = function(val){};  3.模块标识：</code></pre></li><li><p>node模块实现：</p><p>  node引入模块需要3个步骤：路径分析、文件定位、编译执行，其中系统自带的模块为核心模块，直接随node启动时加载进内存，加载速度快；用户自定义的模块称为文件模块，在运行时动态加载，慢。</p><pre><code>  1.路径分析：require(&#39;标识符&#39;)；//分析标识符，标识符主要分为：      *核心模块，如http、fs、path等。      *.或..等相对路径文件模块      *以/开始的绝对路径文件模块      *非路径形式的文件模块，如自定义的connect模块          （自定义模块非核心模块和路径形式的模块，分析速度最慢）  2.文件定位：      *扩展名分析：模块文件可以不带扩展名，自动按.js、.json、.node顺序补全。      *目标分析和包：  3.模块编译      *核心模块一般为C/C++或javascript编译，所有的都转换为C/C++然后编译  4.内建模块：全由C/C++编译的模块，使用：      process.binding(&#39;标识符&#39;)      来进行导出</code></pre></li><li><p>包与NPM：</p><pre><code>  &quot;package.json&quot;：包含包的所有信息（版本、名称、作者等）  NPM已经是一个包共享平台，实现第三方模块的发布、安装和依赖。</code></pre></li><li><p>前后端共用模块：</p><p>  前端规范：AMD规范、CMD规范</p><pre><code>  1.AMD规范定义的模块需要用define：  define(function(){...})  2.CMD规范申明时要指定所有的依赖</code></pre></li></ul><p>##第三章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##第一章 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Node&lt;/p&gt;
&lt;p&gt;  Node：“一个强制不共享任何资源的单线程、单进程系统，通过协议构建不同的node来形成一个大型的网路应用，每一个node为一个节点”，这是书中给的解释原文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非阻塞I
      
    
    </summary>
    
    
      <category term="read" scheme="http://yoursite.com/tags/read/"/>
    
  </entry>
  
</feed>
