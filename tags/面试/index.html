<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Tag: 面试 | 一条想成为大佬的咸鱼</title>
    <meta name="author" content="Ted Qin" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Sanonz">
                </a>
            </div>
            
            <div class="author-name">TedQin</div>
            <div class="author-work"></div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Shanghai, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                    <a class="thread-item" href="https://github.com/tedqin" target="_blank" rel="noopener"><i class="icon-github"></i></a>
                    
                    
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/04/17/前端工程师面试总结/">前端工程师面试总结</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2019/04/17/前端工程师面试总结/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-04-17T09:29:13.000Z" itemprop="datePublished">2019-04-17</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/面试/">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>##1 自我介绍<br>我叫秦乐天，本科毕业于同济大学电子与信息工程学院信息安全专业，主要学习计算机科学方面的课程，研究生正就读于伦敦国王学院计算机系统与管理专业，（1学习方面）本科期间参加过程序设计比赛，数学建模和创新实践项目等，获得了上创免答辩立项，全国数学建模大赛二等奖等，本科毕业设计获得了同济大学优秀论文奖。（2工作经历方面）我曾经在饿了么，中科院自动化所和四川长虹股份有限公司的研发岗实习。（3特质）我认为自己的学习能力抗压能力都很强，本科期间自学了python和tensorflow等j机器学习相关工具，以及前端和对应的框架。擅长团队协作，本科期间作为组长带领团队获得了上海大学生创业大赛优秀项目奖。（4工作）我非常喜欢华为“以奋斗者为本”的理念，我一直都想通过自己的努力不断提升和进步，希望自己能够进入华为研发岗并尽自己的一份力</p>
<p>##2 项目介绍<br>    简单介绍 采用技术/担任职责 主要问题&amp;解决方法 闪光点</p>
<p>###2.1 上创：</p>
<ul>
<li>小组组长 主要负责flask项目中的后端算法，参与前后端整合</li>
<li>web应用，协同过滤算法 书籍推荐系统，建立在学校推出的图书评分系统上</li>
<li>应用主要内容分为2块：<ul>
<li>1是根据用户推荐书籍<ul>
<li>老用户<ul>
<li>基于用户推荐：计算用户与其他用户之间的关系度（欧几里得/皮尔逊距离），得到相似度高的用户，并遍历字典，计算不同用户相似度和偏好书籍的权值，得到推荐结果</li>
<li>基于书籍推荐：将评分字典倒置，计算某本书的相似书籍的矩阵，然后相似的计算书籍以及最相似书籍的字典，最后遍历计算不同书籍相似度和评分的权值</li>
</ul>
</li>
<li>新用户：<ul>
<li>根据提供的学院，教师/学生，年级等信息进行加权推荐 </li>
</ul>
</li>
</ul>
</li>
<li>2是对过往2年的图书借阅记录进行统计<ul>
<li>得到过往两年的图书馆真实节约数据，数据预处理：清洗脏数据</li>
<li>数据可视化，用dashboard展现出来</li>
</ul>
</li>
</ul>
</li>
<li>结构：<br>框架：flask<br>前端：输入用户id-submit-通过request.form进入后台-后台算法得出结果-返回<br>后端：python协同过滤算法</li>
<li>遇到的问题：<ul>
<li>推荐速度慢<ul>
<li>原因：每次执行算法都需要遍历整个借阅记录，每个遍历还需要计算一次距离；计算量大</li>
<li>解决方法：在计算一次后，将字典存储再来，在之后的推荐时直接调用，时间大幅减少</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-大创：alexnet分类图像"><a href="#2-2-大创：alexnet分类图像" class="headerlink" title="2.2    大创：alexnet分类图像"></a>2.2    大创：alexnet分类图像</h3><ul>
<li>个人创新项目</li>
<li>python tensroflow 实现优化后的cnn图像分类模型，并调用pytorch预训练的模型，分类1000类不同风格的图像，1w+测试图像超过75准确率。</li>
<li>改进的cnn网络（归一化层，使得图像能有更大尺寸和分辨率的输入 层数更多，分类更准确）</li>
</ul>
<h3 id="2-3-毕设"><a href="#2-3-毕设" class="headerlink" title="2.3    毕设"></a>2.3    毕设</h3><ul>
<li>也是导师的实验室项目，大二暑假开始做</li>
<li>深度生成对抗网络（dcgan）实现图像修复模型，可以对不同损失面积，不同类型损失区域（中央一半马赛克低像素随机缺失）的图像进行复原，</li>
<li>tensorflow+opencv+openface+gpu，</li>
<li>采用技术：<ul>
<li>用cnn实现gan模型，包含d和g，g伪造图像d判断真假，博弈训练（d输入真和假，输出0-1；g输出伪造图像并作为输入迭代生成新伪造图像；）修复阶段让trained g迭代一定次数，最后图像和原图像叠加，得到修复后的图像</li>
<li>3个损失函数：训练阶段1个和修复阶段2个（知觉+环境） 梯度下降</li>
<li>4个不同类型的数据集，超过20w张图像 人脸 建筑 综合 </li>
<li>3个测试指标提高容错性：峰值信噪比psnr 结构相似性ssim 均方根误差rmse 提高单指标容错性，测试结果比传统的图像修复技术都好</li>
</ul>
</li>
<li>亮点：<ul>
<li>优化：直接将原图像和伪造图像叠加不自然；柏松融合 利用插值构建融合部分的像素更加平滑</li>
<li>openface库：预处理阶段，图像中的人脸位置不均，大小不一，openface了一识别人脸并裁减成模型需要的输入</li>
</ul>
</li>
<li>主要问题：训练不平衡：d损失率远大于g，所以给d加了第二个环境损失函数（未受损区域的像素差异），并让两个损失函数加权求和，提高d的训练程度</li>
</ul>
<h3 id="2-4-中科院自动化所："><a href="#2-4-中科院自动化所：" class="headerlink" title="2.4    中科院自动化所："></a>2.4    中科院自动化所：</h3><ul>
<li>人脸检测优化：</li>
<li>在行人检测这种，人脸尺寸小分辨率低的场景下，使用gan进行人脸的超分辨率重建，让人脸检测更加准确</li>
<li>g：生成伪造人脸。d：判断伪造的图像是否真实并且高分辨率</li>
<li>优点：多损失函数加权，相比传统gan更加高效<ul>
<li>3损失函数：伪造（接近人脸）；对抗（交叉墒，判断高分辨率）；分辨（分辨人脸）</li>
</ul>
</li>
<li>gan人脸生成，并让生成的人脸通过google人脸识别api facenet</li>
<li>cnn实现gan    </li>
<li>adam优化器调整学习旅</li>
<li>gpu加速</li>
</ul>
<h3 id="2-5-饿了么："><a href="#2-5-饿了么：" class="headerlink" title="2.5    饿了么："></a>2.5    饿了么：</h3><ul>
<li>arima和lstm模型预测集群作业的数据<ul>
<li>arima纯数学模型，对有周期性的序列拟合更好，</li>
<li>lstm更适合周期性不强的时间序列问题，并且具有多变量的输入维度（给的原始数据多维，但是一开始并不知道它们之间的相关性），拟合度超过85，准确率超过80</li>
</ul>
</li>
<li>预测未来一周的作业数量 hdfs资源占用情况和作业严重级别，</li>
<li>最后模型部署到公司的日志监控系统上</li>
<li>闪光点：单独写脚本选择出了针对以往数据的最优的arima参数/lstm多维输入</li>
</ul>
<h3 id="2-6-长虹"><a href="#2-6-长虹" class="headerlink" title="2.6    长虹"></a>2.6    长虹</h3><ul>
<li>对14种不同的票据分类 两个模型 票据量小传统的svm准确率高，量大用cnn（lenet）先做训练，然后分类</li>
<li>难点：预处理和特征提取：黑白文字，且票据的扫描件位置大小层次不齐；cnn能识别图像，但是对于文字识别较难，</li>
<li>优化：opencv库的函数让图像翻转，同样opencv做了数据增强，gan超分辨率，裁减。增加了模型的层数，扩大归一化尺寸；</li>
</ul>
<h3 id="2-7-数学建模"><a href="#2-7-数学建模" class="headerlink" title="2.7    数学建模"></a>2.7    数学建模</h3><ul>
<li>主要内容是拟合atm交易的数据，采用平均联动聚类以后用核拟合找出特征值，真实数据数据清洗最重要，脏数据的删除，空数据的删除和补充</li>
</ul>
<h3 id="2-8-智能交通实验室"><a href="#2-8-智能交通实验室" class="headerlink" title="2.8    智能交通实验室"></a>2.8    智能交通实验室</h3><ul>
<li>主要工作是前端构建，并写了一个api连接后端，后端用node采用sklearn（机器学习库），实现了svm，对交通流量数据进行分类</li>
<li>ajax在交通流量实时更新的情况下可以动态更新分类结果</li>
</ul>
<h2 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a>3. 操作系统</h2><ul>
<li>3.1 进程和线程的区别是什么？<ul>
<li>进程：分配资源的最小单元</li>
<li>线程：程序执行的最小单元</li>
<li>一个进程可以包含多个线程；进程启动的时候cpu需要给他分配资源，对系统压力比进程大，你可以把线程看成是轻量级的进程。</li>
<li>区别： <ul>
<li>进程：有独立数据段，需要分配独立空间（资源大安全高）； <pre><code>      通信机制复杂
</code></pre></li>
<li>线程：共享数据段，不需要分配独立空间（资源小安全低）；<pre><code>      通信机制方便
</code></pre></li>
</ul>
</li>
<li>选取原则：<ul>
<li>进程：多机（cpu效率低），稳定安全</li>
<li>线程：频繁的创建和销毁；大量计算；耗时；多核（cpu效率高）；并行操作</li>
</ul>
</li>
</ul>
</li>
<li><p>3.2 进程间通信的方式有什么？线程间通信的方式有什么？</p>
<ul>
<li>进程：socket，管道，信号，消息，共享内存等多种方式</li>
<li>线程：共享变量，管道</li>
</ul>
</li>
<li><p>3.3    什么是缓存？有哪些缓存的更新算法？</p>
<ul>
<li>存储信息避免重复加载；</li>
<li>强缓存：Cache：高速交换存储器；expires</li>
<li>协商缓存：last-modified和if-modified-since：如果缓存过期用</li>
<li>更新算法：Lfu,lru,fifo: lru:least recent update: 最近不访问或者访问少的今后也不会访问（linklist+hashmap实现）</li>
</ul>
</li>
<li><p>3.4    当你输入域名访问一个网站的时候，背后的过程是什么？</p>
<ul>
<li>DNS域名解析-TCP三次握手-nginx反向代理进行负载均衡（前后端分离）</li>
</ul>
</li>
</ul>
<p>3.5    多线程中有哪些锁<br>1）    偏向锁 加锁和解锁不需要额外的消耗，如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块场景。<br>2）    轻量级锁：竞争的线程不会阻塞，提高了程序的响应速度。如果始终得不到锁竞争的线程使用自旋会消耗CPU。    追求响应时间。同步块执行速度非常快。<br>3）    重要级锁：线程竞争不使用自旋，不会消耗CPU。    线程阻塞，响应时间缓慢。追求吞吐量。同步块执行速度较长。<br>3.6    线程的状态：<br>初始new-<br>运行runnable-分为就绪ready（调用线程的start()方法，此线程进入就绪状态，sleep（）结束）和运行中running<br>阻塞blocked-阻塞于锁<br>等待waiting<br>超时等待timeed_waiting-可以在指定时间后自行返回<br>终止-</p>
<p>3.7    创建线程两种方式的区别：<br>1)    继承Thread类，并且覆盖Thread类的run()方法。这种方法的优点是Thread子类对象就是线程对象，具有Thread类的方法，且具有线程体，但是不适应多继承<br>2)    实现Runnable接口：如果一个类已经继承了一个类还必须要以线程方式运行，就需要实现Runnable接口。实现Runnable接口的类的对象本身并不是线程对象，只是作为一个创建线程对象的目标对象使用。<br>3.8    聊天都是新建线程，会影响内存，怎么处理<br>1）开源(增加内存分配)<br>2）.节流(内存优化):<br>3.9    线程之间共享数据的方式<br>将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。<br>将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方式也分配给外部类<br>3.10    进程通信（分别解释），ping工作原理，中断，线程共享父线程的什么，<br>Ping:命令行指令，一般用于检测网络通与不通 ，也叫时延，其值越大，速度越慢<br>中断是一种特殊的信号，由硬件设备向CPU发送（如敲击键盘）。当CPU接收到中断信号后，就会马上通知操作系统此信号的到来，然后由操作系统负责处理这些新到来的数据。</p>
<p>4    网络协议：<br>4.1 计算机网络分为哪几层？<br>计算机网络如果是OSI模型的话，分为七层：<br>物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS<br>数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM,  IEEE 802.5/802.2<br>网络层：IP，IPX，AppleTalk DDP<br>传输层：TCP，UDP，SPX<br>会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP<br>表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML<br>应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP<br> TCP／IP协议簇模型的话，分为四层：<br>数据链路层：ARP,RARP<br>网络层： IP,ICMP,IGMP<br>传输层：TCP ,UDP,UGP<br>应用层：Telnet,FTP,HTTP，SMTP,SNMP. </p>
<p>4.3    TCP和UDP有什么区别？什么场景使用TCP，什么场景什么UDP？哪些应用层协议使用了TCP，哪些使用了UDP？<br>TCP是可靠传输的：用在发送消息的场景（保证用户数据不丢失）<br>UDP是不可靠传输的：传输快：用在聊天室直播等场景（迅速，即使少量丢包不影响）<br>4.4    窗口滑动协议？<br>tcp中，两端都维护着窗口：<br>发送端窗口：由接受端窗口给出的剩余长度来定义<br>接收端窗口：<br>实现流量控制，<br>4.5    TCP连接需要几次握手？几次分手？<br>3次握手：<br>    两个序号和三个标志位：<br>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。<br>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<br>（A）URG：紧急指针（urgent pointer）有效。<br>（B）ACK：确认序号有效。<br>（C）PSH：接收方应该尽快将这个报文交给应用层。<br>（D）RST：重置连接。<br>（E）SYN：发起一个新连接。<br>（F）FIN：释放一个连接。<br>1在第一次消息发送中，客户端把自己的初始序号发送给服务端；<br>2服务端收到，发送一个应答，也包含自身数据的初始序列号<br>3当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。</p>
<p>4次分手：<br>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<br>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？<br>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，收到对方的FIN报文时，<br>仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，<br>再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<p>4.6    Socket：<br>客户端和服务端需要采用socket连接时，需要建立socket连接|（应用层与传输层），应用层通过socket向网络发送请求建立tcp/udp连接<br>一个简单的server：<br>4.7    IO NIO AIO：<br>Socket在读取消息的时候是阻塞的，NIO是非阻塞，AIO是异步非阻塞，<br>4.8    你用过什么linux命令？<br>Ls cd pwd cp rm whereis gedit<br>4.9    POST和GET的区别：<br>Post是向服务器传送出数据，get是从服务器获取数据<br>Get通过url传递，post通过request body<br>4.10    http和tcp：<br>http：<br>tcp是传输层协议，定义的是数据传输和连接方式的规范；</p>
<p>http是应用层协议，定义的是传输数据的内容的规范；HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP；</p>
<p>TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。<br>4.11    https:在http（明文传输）的基础上加入了SSL层进行加密传输<br>4.12    http2: 所有数据采用二进制编码；一个tcp存在多条流；header压缩；<br>4.13    ARQ协议：<br>超时重重传机制：通过确认和超时机制保证数据的正确送达<br>停止等待arq:<br>连续arq：<br>4.14    拥塞处理<br>慢开始（拥塞处理窗口）-拥塞避免算法-快速重传<br>4.15    http常见状态码：<br>2xx 成功<br>3xx 重定向<br>4xx 客户端错误<br>5xx 服务器错误</p>
<p>5    数据结构<br>5.1 表：<br>    顺序表：删除/插入节点需要移位<br>    链表：删除/插入节点即可，无需移位<br>5.3    栈 队列<br>栈：插入/删除都在栈头执行<br>队列：删除在队头，插入在队尾<br>        单链队列：循环队列：<br>5.4    查找算法：<br>顺序搜索：<br>二分搜索：<br>指数搜索：index=1-2-4-8-16-32-…<br>5.5    二叉树<br>满：full<br>完全：其它层都满，除了最后一层，如果最后一层不满，节点必须集中在左边<br>遍历：先序VLR 中序LVR 后序LRV<br>平衡：对任意节点，左比根小，右比根大：<br>Avl：任一节点的孩子节点高度差最大为1；红黑：非黑即白；Root是黑色；红色的儿子必须是黑色<br>5.6    堆<br>最大堆：每个节点值比它的子节点都大，且是完全二叉树<br>5.7    排序<br>堆排：while（heap.length）  {交换最后一个元素和堆顶元素，删除最后一个元素，然后调整为正确堆}<br>冒泡：把当前元素和下一个元素比较，当前元素大就交换位置<br>插排：i++ 以此将当前元素和在它之前的序列中排到正确位置<br>选择排序：遍历一遍找到最小的数，放到第一位，递归<br>快排：随机选pivot，左边的数比它大，右边的比它小，对左边的和右边的递归<br>归并排序：从中拆分成两组，分别排序，递归 最后合并</p>
<p>5.8    字典<br>哈希表：key-value存储结构；<br>冲突：线性探查（直接往后找空位）<br>          平方探查（往后找空位按照1-2-4-8来找）<br>          链地址（同义词组成单链表）<br>          再哈希（）<br>5.9    图<br>表示方法：邻接表，邻接矩阵<br>最小生成树：原图的连通子图，weight最小<br>                计算方法：prim（从第一个点开始加点，每次找权重最小的边连起来的点）<br>                         Kruscal（确定所有点，链接权重最小的边）<br>最短路径：从点u到其他所有点的最短路径<br>            计算方法：dijkstra（给两个集合A={u}，B{其他点}， 从B中找到A的最短路径，加入A）<br>DFS（顶点开始，递归访问相邻点，若有点被访问，则回溯到另一个未被访问的顶点） BFS（顶点开始，依此访问所有相邻点）<br>动态规划<br>5.10    hashmap与hashtable与hashset的区别</p>
<p>6    算法<br>6.1 进制转换：<br>dec-bin：整数：除2取余；小数：乘2取整<br>bin-dec：</p>
<p>6.2 左移 &lt;&lt;：10 在二进制中表示为 1010 ，左移一位后变成 10100<br>6.3 算数右移：10 在二进制中表示为 1010 ，右移一位后变成 101<br>6.4  动态规划： 将问题拆分成子问题，得到子解就得到了大解（斐波那契数列，</p>
<p>7    git：<br>checkout：定位到某分支<br>branch：创建新分支<br>merge：合并<br>恢复先前的提交：让head后移一位，<br>commit：当当前的改动提交到本地的版本库<br>reset和rebase：reset不修改commit；rebase会修改commit<br>pull和fetch：pull会更新本地代码库；fetch是取回远端更新，不会对本地执行merge</p>
<p>8    前端：<br>8.1 js基本类型：<br>    null<br>undefined<br>Boolean<br>number<br>string<br>symbol<br>object<br>8.3    类型转换String(234)=’234’<br>对象转基本类型：tostring，（先valueof）<br>8.4    ==和===：<br>===：严格相等，会比较类型和值<br>==：先类型转化再比较值<br>8.5    new：<br>新生成一个对象-链接到原型-绑定this-返回新对象<br>8.6    this：<br>只在函数内部使用，自动生成的一个对象，绑定函数<br>8.7    执行上下文：<br>当执行 JS 代码时，会产生三种执行上下文<br>•    全局执行上下文<br>•    函数执行上下文<br>•    eval 执行上下文<br>每个执行上下文中都有三个重要的属性<br>•    变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问<br>作用域链: 包含自身变量对象和上级变量对象的列表<br>•<br>•    this</p>
<p>8.8    闭包：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包</p>
<p>8.9    深浅拷贝<br>直接赋值进行拷贝：两者的值会是同一个引用<br>浅拷贝：b={…a}<br>深拷贝：通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。</p>
<p>8.10    commonjs：<br>node规范：引入了模块机制：require export<br>8.11     amd：异步定义<br>8.12    防抖：<br>防止二次点击操作：防止函数多次调用（例如用户多次滑动页面）：通过限制需要经过的时间，直到再次调用函数，将多次执行-&gt;最后一次执行<br>8.13    节流：也可防抖，在固定时间内只能调用一次，多次执行-&gt;每隔一段时间执行<br>8.14     继承：es5提出，在父对象的原型链上定义属性<br>class<br>8.15    call apply bind的区别：<br>call，apply：改变this的指向，让新的对象可以执行该函数；bind最后会返回一个函数<br>8.16    promise：<br>初始态pending：通过resolve和reject改变</p>
<p>8.17    generator 异步编程 函数名前加*，可以返回next进行代码暂停<br>8.18    map flatmap reduce<br>map：Map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 append 到新的数组中</p>
<p>flatmap：降纬<br>reduce：作用是数组中的值组合起来，最终得到一个值</p>
<p>8.19     async await<br>async函数返回promise 异步调用<br>8.20    proxy：<br>自定义对象中的操作，实现一个数据绑定和监听</p>
<p>8.21     为什么 0.1 + 0.2 != 0.3<br>js采用ieee 64位版本，0．1和0.2都是无限循环的二进制，末尾会进位，不是标准的3.00000<br>8.22    正则表达式</p>
<p>9    浏览器<br>9.1    事件机制:<br>事件触发3阶段<br>：<br>事件代理：子节点动态生成，应注册在父节点上（节省空间）<br>9.2    cookie session的区别：cookie存储sessionid<br>9.3    浏览器兼容性：<br>css兼容：定制自己的reset.css<br>交互兼容性：<br>9.4    js组成：ecmascript（定义脚本语言的属性、方法和对象）+dom（把整个页面规划成由节点层级构成的文档）+bom（处理浏览器宽口和框架）<br>9.5    ajax优缺点：<br>优：减轻服务器的负担，按需取数据，最大程度减少冗余请求，局部刷新。<br>缺：浏览器之间有差异，对流媒体和移动设备支持不够好<br>9.6    浏览器内核<br>渲染引擎：负责取得网页的内容、整理讯息，以及计算网页的显示方式<br>js引擎：析和执行js来实现网页的动态效<br>9.7    事件委托<br>9.8    window的onload事件和domcontentloaded谁先谁后？<br>9.9    跨域问题：<br>协议，域名或端口有一个不同就是跨域，ajax请求会失败<br>解决：jsonp：利用<script>标签（没有跨域限制的漏洞）指向地址并提供回调函数来接收（只限于get）<br>    cors：该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<br>    document.domain：该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。<br> postmessage：这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
<p>只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域</p>
<p>#<br>9.10    restful：api风格，用URL定位资源，用HTTP描述操作<br>9.11    事件循环：<br>浏览器：同步执行代码-遇到settimeout，把该事件放到事件队列（遇到微任务放到微任务空间）继续执行直到同步代码执行结束；之后执行微任务空间，然后执行事件队列中的事件，反复循环<br>node：执行顺序不一定<br>9.12    存储：</p>
<p>cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<p>10    性能<br>10.1 预加载：有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p>
<p>10.2 预渲染：<br>10.3 优化渲染过程：懒执行（某些逻辑延迟到使用时再计算）+懒加载（不关键的资源延后加载）<br>10.4 图片优化：减小像素点+减小每个像素点的颜色+加载优化<br>    文件优化：css文件放在head中，script标签放在body底部（js会阻塞渲染）</p>
<p>11    安全<br>11.1    xss：跨网站指令码：这类攻击包含html以及恶意脚本语言<br>修改html节点或执行js<br>防御：白名单（csp内容安全层）/黑名单过滤/转义输出<br>11.2    csrf：跨站请求伪造：挟持用户在当前登陆设备上攻击网站<br>在评论（get接口）中加入恶意代码<br>防御：进制修改get</p>
<p>12    框架<br>12.1    mvvm：view+model+viewmodel<br>视图：ui组件<br>model：数据模型，业务逻辑<br>viewmodel：监听模型数据的改变和控制试图<br>12.2    路由：监听URL变化，然后匹配路由规则：<br>路由方式：hash模式：路由#后面加hash值<br>/ history模式：pushstate（）replacestate（）对浏览器记录进行修改<br>12.3    virtual dom：<br>用js模拟dom对象（节点和渲染）</p>
<p>13    vue<br>13.1    nexttick：<br>下次dom更新循环结束之后执行延迟回调，用于获得更新后的dom<br>13.2    生命周期分析<br>vue实例从创建到销毁的过程：创建前/后-挂载dom前/后-渲染更新前/后-卸载前/后<br>组件在初始化或者数据更新时会出发的钩子函数（类似回调）<br>第一次加载页面会触发：beforecrate created beforemount mounted<br>13.3    vue组件参数传递：<br>父-&gt;子：子通过props方法接受数据<br>子-&gt;父：emit方法传递参数</p>
<p>14    死锁：系统资源不足/分配不当，进程推进顺序不合理，争夺有限的资源而陷入死锁<br>synchronized锁和lock的区别：<br>    同步锁：可以放在方法或者代码块前面 需要指定上锁的对象<br>    lock：可以代替同步锁，但是有中断，和定时锁等待<br>    区别：资源竞争激烈：lock性能比同步好；<br>            反之：同步好<br>            同步锁可以在代码块前面实现<br>死锁的条件<br>    互斥：一个进程使用一个资源<br>    请求与保持：一个进程请求资源造成阻塞，且对已有的资源不放<br>    不剥夺：进程已获得资源在使用完之前，不能强行剥夺<br>    循环等待：若干进程形成循环等待资源的关系<br>摈弃死锁的条件：<br>    合理分配资源<br>    避免进程永久占据资源<br>    防止处于等待状态下的进程占用资源</p>
<p>15    设计模式：<br>15.1    单例模式：确保一个类只有一个实例，确保了封装行：将构造函数声明为private<br>15.2     工厂模式：创建类时不会暴露创建内容，而是通过接口实例化类；更方便构造对象<br>15.3     装饰器设计模式：动态给对象添加属性或函数；<br>15.4     观察者模式：对象1对多，多个观察者可以监听某个对象；自动更新<br>15.5    </p>
</script></p>
        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
